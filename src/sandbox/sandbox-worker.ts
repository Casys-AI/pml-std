/**
 * Sandbox Worker - Isolated Code Execution with RPC Tool Proxies
 *
 * Story 7.1b / ADR-032: Worker script that executes user code in isolation.
 * Story 7.3b: Capability injection with BroadcastChannel tracing (ADR-036).
 *
 * Security Model:
 * - Runs with `permissions: "none"` (Deno Worker permission)
 * - No direct access to filesystem, network, or environment
 * - Tool calls route through RPC bridge to main process
 * - Capability traces emitted via BroadcastChannel (real-time)
 *
 * @module sandbox/sandbox-worker
 */

/// <reference lib="deno.worker" />

import type {
  BridgeToWorkerMessage,
  CapabilityTraceEvent,
  InitMessage,
  RPCResultMessage,
  ToolDefinition,
} from "./types.ts";

// Declare Worker global scope for TypeScript
declare const self: DedicatedWorkerGlobalScope;

// =============================================================================
// Story 7.3b: Capability Tracing via BroadcastChannel (ADR-036)
// ADR-041: Hierarchical trace tracking with parentTraceId propagation
// =============================================================================

/**
 * BroadcastChannel for real-time trace emission
 * Bridge subscribes to this channel to receive capability traces
 * Channel name: PML_TRACES_CHANNEL from src/events/event-bus.ts
 */
const traceChannel = new BroadcastChannel("pml-traces");

// ADR-041: Context stack for hierarchical trace tracking
// Tracks current trace context (traceId of active capability)
// Stack supports nested capabilities: [outermost, ..., current]
interface TraceContext {
  traceId: string;
  capability: string;
  capabilityId: string;
}
const __traceContextStack: TraceContext[] = [];

// ADR-041: Root parent trace ID from workflow/task context
// Initialized from InitMessage.parentTraceId
let __rootParentTraceId: string | undefined;

/**
 * Get current trace context (for parentTraceId propagation)
 * Returns the traceId of the currently executing capability,
 * or the root parent trace ID from workflow, or undefined
 */
function __getCurrentTraceId(): string | undefined {
  if (__traceContextStack.length === 0) return __rootParentTraceId;
  return __traceContextStack[__traceContextStack.length - 1].traceId;
}

// Note: __capabilityDepth is now closure-scoped in the capability context
// (generated by CapabilityCodeGenerator.buildCapabilitiesObject)
// This prevents user code from manipulating it directly (Issue #4 fix)

/**
 * Trace function for capability events
 * Emits traces via BroadcastChannel for real-time collection
 * ADR-041: Manages trace context stack and propagates parentTraceId
 *
 * @param event - Partial trace event (type, capability, capabilityId required)
 */
function __trace(event: Partial<CapabilityTraceEvent>): void {
  try {
    // ADR-041: Generate traceId for this event
    const traceId = crypto.randomUUID();

    // ADR-041: Get parentTraceId from current context (before push/pop)
    const parentTraceId = event.type === "capability_start"
      ? __getCurrentTraceId() // Parent is the CURRENT top of stack (or root)
      : undefined; // For capability_end, parent is already set

    const fullEvent: CapabilityTraceEvent = {
      type: event.type as "capability_start" | "capability_end",
      capability: event.capability || "unknown",
      capabilityId: event.capabilityId || "unknown",
      traceId: traceId,
      ts: Date.now(),
      success: event.success,
      error: event.error,
      parentTraceId: parentTraceId,
      args: event.args,
      result: event.result, // Story 11.1
      durationMs: event.durationMs, // Story 11.1
    };

    // ADR-041: Manage trace context stack
    if (event.type === "capability_start") {
      // Push new context onto stack
      __traceContextStack.push({
        traceId: traceId,
        capability: event.capability || "unknown",
        capabilityId: event.capabilityId || "unknown",
      });
    } else if (event.type === "capability_end") {
      // Pop context from stack (find matching capability)
      // Use capabilityId to match in case of concurrent calls
      const idx = __traceContextStack.findLastIndex(
        (ctx) => ctx.capabilityId === event.capabilityId,
      );
      if (idx !== -1) {
        // Update fullEvent.traceId to match the start event
        fullEvent.traceId = __traceContextStack[idx].traceId;
        __traceContextStack.splice(idx, 1);
      }
    }

    traceChannel.postMessage(fullEvent);
  } catch {
    // Never throw - tracing must not break execution
  }
}

// Cleanup on worker termination
self.addEventListener("unload", () => {
  traceChannel.close();
});

/**
 * Pending RPC calls waiting for response from bridge
 */
const pendingCalls = new Map<string, {
  resolve: (value: unknown) => void;
  reject: (error: Error) => void;
}>();

/**
 * RPC call function - sends message to bridge and waits for response
 * ADR-041: Includes parentTraceId for hierarchical tracking (capability â†’ tool)
 *
 * @param server MCP server identifier
 * @param tool Tool name
 * @param args Tool arguments
 * @returns Tool execution result
 */
async function __rpcCall(
  server: string,
  tool: string,
  args: Record<string, unknown>,
): Promise<unknown> {
  const id = crypto.randomUUID();

  // ADR-041: Get current trace context for parentTraceId
  const parentTraceId = __getCurrentTraceId();

  return new Promise((resolve, reject) => {
    pendingCalls.set(id, { resolve, reject });

    // Send RPC request to bridge with parentTraceId (ADR-041)
    self.postMessage({
      type: "rpc_call",
      id,
      server,
      tool,
      args,
      parentTraceId, // ADR-041: Propagate trace context
    });
  });
}

/**
 * Generate tool proxy object from definitions
 *
 * Creates an object structure like:
 * ```
 * {
 *   filesystem: {
 *     read_file: (args) => __rpcCall("filesystem", "read_file", args),
 *     write_file: (args) => __rpcCall("filesystem", "write_file", args),
 *   },
 *   memory: {
 *     store: (args) => __rpcCall("memory", "store", args),
 *   }
 * }
 * ```
 */
function generateToolProxies(
  toolDefinitions: ToolDefinition[],
): Record<string, Record<string, (args: Record<string, unknown>) => Promise<unknown>>> {
  const knownServers: Record<string, Record<string, (args: Record<string, unknown>) => Promise<unknown>>> =
    {};

  for (const def of toolDefinitions) {
    if (!knownServers[def.server]) {
      knownServers[def.server] = {};
    }
    knownServers[def.server][def.name] = (args: Record<string, unknown>) =>
      __rpcCall(def.server, def.name, args);
  }

  // Return a Proxy that:
  // 1. Returns known MCP servers as-is
  // 2. For unknown servers, returns a Proxy that creates RPC calls on-the-fly
  //    This allows capability calls like mcp.fs.ls() to be routed to WorkerBridge
  return new Proxy(knownServers, {
    get(target, serverName: string) {
      // Return known server if exists
      if (target[serverName]) {
        return target[serverName];
      }
      // For unknown servers, return a Proxy that creates RPC functions on-the-fly
      // These will be routed to capabilities by WorkerBridge if capabilityRegistry is set
      return new Proxy({}, {
        get(_target, toolName: string) {
          return (args: Record<string, unknown> = {}) =>
            __rpcCall(serverName, toolName, args);
        },
      });
    },
  });
}

/**
 * Execute user code with tool proxies and capabilities available
 *
 * @param code User code to execute
 * @param mcp Tool proxy object
 * @param context Optional context variables
 * @param capabilityContext Optional capability code (inline functions)
 * @returns Execution result
 */
async function executeCode(
  code: string,
  mcp: Record<string, Record<string, (args: Record<string, unknown>) => Promise<unknown>>>,
  context?: Record<string, unknown>,
  capabilityContext?: string,
): Promise<unknown> {
  // Build context variables for injection
  const contextVars = context
    ? Object.entries(context)
      .map(([key, value]) => `const ${key} = ${JSON.stringify(value)};`)
      .join("\n")
    : "";

  // ADR-016: REPL-style auto-return with heuristic detection
  // Check if code contains statement keywords
  const hasStatements =
    /(^|\n|\s)(const|let|var|function|class|if|for|while|do|switch|try|return|throw|break|continue)\s/
      .test(code.trim());

  // If code has statements, execute as-is (requires explicit return)
  // If code is pure expression, wrap in return for auto-return
  const wrappedUserCode = hasStatements ? code : `return (${code});`;

  // Create async function with mcp, capabilities, and tracing injected
  // Using Function constructor (required for dynamic code execution in Worker)
  const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;

  // Build function body with capability context, context vars, and user code
  // Story 7.3b: __trace is passed as parameter, __capabilityDepth is closure-scoped in capability context
  const functionBody = `
    ${capabilityContext || "let __capabilityDepth = 0;\nconst capabilities = {};"}
    ${contextVars}
    ${wrappedUserCode}
  `;

  // Create and execute the function with mcp and __trace as parameters
  // __capabilityDepth is closure-scoped within capabilityContext (not a parameter)
  const fn = new AsyncFunction("mcp", "__trace", functionBody);

  return await fn(mcp, __trace);
}

/**
 * Handle messages from bridge
 */
self.onmessage = async (e: MessageEvent<BridgeToWorkerMessage>) => {
  const msg = e.data;

  if (msg.type === "init") {
    await handleInit(msg);
  } else if (msg.type === "rpc_result") {
    handleRPCResult(msg);
  }
};

/**
 * Handle init message - setup and execute user code
 * Story 7.3b: Now accepts capabilityContext for inline capability functions
 * ADR-041: Initializes root parent trace ID for hierarchical tracking
 */
async function handleInit(msg: InitMessage): Promise<void> {
  const { code, toolDefinitions, context, capabilityContext, parentTraceId } = msg;

  // ADR-041: Initialize root parent trace ID from workflow/task context
  __rootParentTraceId = parentTraceId;

  try {
    // Generate tool proxies from definitions
    const mcp = generateToolProxies(toolDefinitions);

    // Execute user code with capabilities (Story 7.3b)
    const result = await executeCode(code, mcp, context, capabilityContext);

    // Send success response
    self.postMessage({
      type: "execution_complete",
      success: true,
      result,
    });
  } catch (error) {
    // Send error response
    self.postMessage({
      type: "execution_complete",
      success: false,
      error: error instanceof Error ? error.message : String(error),
    });
  }
}

/**
 * Handle RPC result message - resolve pending call
 */
function handleRPCResult(msg: RPCResultMessage): void {
  const pending = pendingCalls.get(msg.id);

  if (pending) {
    pendingCalls.delete(msg.id);

    if (msg.success) {
      // Auto-unwrap MCP content format for better DX
      const unwrapped = unwrapMCPContent(msg.result);
      pending.resolve(unwrapped);
    } else {
      pending.reject(new Error(msg.error || "RPC call failed"));
    }
  }
}

/**
 * Unwrap MCP standard content format to provide direct access to data
 *
 * MCP tools return: { content: [{ type: "text", text: "{...}" }] }
 * This unwraps to: { ... } (parsed JSON) or the raw text if not JSON
 *
 * This improves DX by allowing:
 *   const result = await mcp.filesystem.fast_list_directory({ path: "src" });
 *   result.items  // Works directly instead of JSON.parse(result.content[0].text).items
 */
function unwrapMCPContent(result: unknown): unknown {
  if (
    result &&
    typeof result === "object" &&
    "content" in result &&
    Array.isArray((result as Record<string, unknown>).content)
  ) {
    const content = (result as { content: Array<{ type?: string; text?: string }> }).content;
    if (
      content.length === 1 && content[0]?.type === "text" && typeof content[0]?.text === "string"
    ) {
      try {
        return JSON.parse(content[0].text);
      } catch {
        // Not valid JSON, return the text directly
        return content[0].text;
      }
    }
  }
  return result;
}
