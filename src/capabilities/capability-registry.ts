/**
 * Capability Registry (Story 13.1, Migration 028)
 *
 * Registry for named capabilities with UUID primary key and FQDN components.
 *
 * Architecture: Works with `capability_records` table (migration 021, 028)
 * - UUID is the immutable primary key (used in code as mcp["$cap:<uuid>"])
 * - FQDN is computed from: org.project.namespace.action.hash
 * - Display name is derived from: namespace:action
 *
 * @module capabilities/capability-registry
 */

import type { DbClient } from "../db/types.ts";
import type {
  CapabilityRecord,
  CapabilityRouting,
  CapabilityVisibility,
  Scope,
} from "./types.ts";
import { getCapabilityDisplayName, getCapabilityFqdn } from "./types.ts";
import { isValidMCPName } from "./fqdn.ts";
import * as log from "@std/log";

// Re-export for convenience
export type { CapabilityRecord, Scope };

/**
 * Input for creating a new capability record
 *
 * Note: code_snippet, description, parameters_schema, tools_used are stored in
 * workflow_pattern table, linked via workflowPatternId FK (migration 023).
 */
export interface CreateCapabilityRecordInput {
  /** Organization */
  org: string;
  /** Project */
  project: string;
  /** Namespace grouping */
  namespace: string;
  /** Action name */
  action: string;
  /** FK to workflow_pattern.pattern_id (required - code lives there) */
  workflowPatternId: string;
  /** Hash for FQDN generation (4 lowercase hex chars) */
  hash: string;
  /** Who is creating this record */
  createdBy?: string;
  /** Optional tags */
  tags?: string[];
  /** Visibility level (default: private) */
  visibility?: CapabilityVisibility;
  /** Execution routing (default: local) */
  routing?: CapabilityRouting;
}

/**
 * Capability Registry class
 *
 * Provides methods for:
 * - Creating and registering capabilities with UUID PK
 * - Resolving names by scope (namespace:action)
 * - Looking up by UUID or FQDN components
 */
export class CapabilityRegistry {
  private db: DbClient;

  constructor(db: DbClient) {
    this.db = db;
  }

  /**
   * Create a new capability record with auto-generated UUID
   *
   * Note: Code, description, params, tools are in workflow_pattern via FK.
   *
   * @param input - The capability record data
   * @returns The created record with UUID
   */
  async create(input: CreateCapabilityRecordInput): Promise<CapabilityRecord> {
    // Validate namespace:action for MCP compatibility
    const displayName = `${input.namespace}:${input.action}`;
    if (!isValidMCPName(displayName)) {
      throw new Error(
        `Invalid namespace:action: "${displayName}". Must be alphanumeric with underscores, hyphens, and colons only.`,
      );
    }

    const now = new Date();
    const createdBy = input.createdBy || "local";

    // Insert into database - UUID is auto-generated by DB
    // ON CONFLICT uses unique index on (org, project, namespace, action, hash)
    const result = await this.db.query(
      `
      INSERT INTO capability_records (
        org, project, namespace, action, hash,
        workflow_pattern_id, created_by, created_at, visibility, routing, tags
      ) VALUES (
        $1, $2, $3, $4, $5,
        $6, $7, $8, $9, $10, $11
      )
      ON CONFLICT (org, project, namespace, action, hash) DO UPDATE SET
        workflow_pattern_id = EXCLUDED.workflow_pattern_id,
        updated_by = EXCLUDED.created_by,
        updated_at = NOW(),
        version = capability_records.version + 1,
        tags = EXCLUDED.tags
      RETURNING id
    `,
      [
        input.org,
        input.project,
        input.namespace,
        input.action,
        input.hash,
        input.workflowPatternId,
        createdBy,
        now.toISOString(),
        input.visibility || "private",
        input.routing || "local",
        input.tags || [],
      ],
    );

    const id = result[0]?.id as string;
    if (!id) {
      throw new Error(`Failed to create capability record`);
    }

    // Fetch and return the created record
    const record = await this.getById(id);
    if (!record) {
      throw new Error(`Failed to fetch created capability record: ${id}`);
    }

    const fqdn = getCapabilityFqdn(record);
    log.info(`Created capability record: ${fqdn} (id: ${id})`);
    return record;
  }

  /**
   * Get a capability record by UUID
   *
   * @param id - The UUID primary key
   * @returns The record or null if not found
   */
  async getById(id: string): Promise<CapabilityRecord | null> {
    const rows = await this.db.query(
      `SELECT * FROM capability_records WHERE id = $1`,
      [id],
    );

    if (rows.length === 0) {
      return null;
    }

    return this.rowToRecord(rows[0]);
  }

  /**
   * Get a capability record by FQDN components
   *
   * @param org - Organization
   * @param project - Project
   * @param namespace - Namespace
   * @param action - Action
   * @param hash - Hash
   * @returns The record or null if not found
   */
  async getByFqdnComponents(
    org: string,
    project: string,
    namespace: string,
    action: string,
    hash: string,
  ): Promise<CapabilityRecord | null> {
    const rows = await this.db.query(
      `SELECT * FROM capability_records
       WHERE org = $1 AND project = $2 AND namespace = $3 AND action = $4 AND hash = $5`,
      [org, project, namespace, action, hash],
    );

    if (rows.length === 0) {
      return null;
    }

    return this.rowToRecord(rows[0]);
  }

  /**
   * Resolve a name to a capability record within a scope
   *
   * Resolution order:
   * 1. Match by namespace:action format in current scope
   * 2. Match by action only in current scope (if no colon)
   * 3. Public capability match (visibility = 'public')
   *
   * @param name - The namespace:action or action name to resolve
   * @param scope - The org/project scope
   * @returns The resolved record or null
   */
  async resolveByName(
    name: string,
    scope: Scope,
  ): Promise<CapabilityRecord | null> {
    // 1. Try namespace:action format
    const colonIndex = name.indexOf(":");
    if (colonIndex > 0) {
      const namespace = name.substring(0, colonIndex);
      const action = name.substring(colonIndex + 1);

      const namespaceMatch = await this.db.query(
        `SELECT * FROM capability_records
         WHERE org = $1 AND project = $2 AND namespace = $3 AND action = $4`,
        [scope.org, scope.project, namespace, action],
      );

      if (namespaceMatch.length > 0) {
        return this.rowToRecord(namespaceMatch[0]);
      }
    } else {
      // 2. Try action only (search across all namespaces in scope)
      const actionMatch = await this.db.query(
        `SELECT * FROM capability_records
         WHERE org = $1 AND project = $2 AND action = $3
         LIMIT 1`,
        [scope.org, scope.project, name],
      );

      if (actionMatch.length > 0) {
        return this.rowToRecord(actionMatch[0]);
      }
    }

    // 3. Try public capability match
    if (colonIndex > 0) {
      const namespace = name.substring(0, colonIndex);
      const action = name.substring(colonIndex + 1);

      const publicMatch = await this.db.query(
        `SELECT * FROM capability_records
         WHERE namespace = $1 AND action = $2 AND visibility = 'public'
         LIMIT 1`,
        [namespace, action],
      );

      if (publicMatch.length > 0) {
        return this.rowToRecord(publicMatch[0]);
      }
    }

    return null;
  }

  /**
   * List all capabilities in a scope
   *
   * @param scope - The org/project scope
   * @param limit - Maximum results (default: 100)
   * @param offset - Pagination offset (default: 0)
   * @returns List of capability records
   */
  async listByScope(
    scope: Scope,
    limit = 100,
    offset = 0,
  ): Promise<CapabilityRecord[]> {
    const rows = await this.db.query(
      `SELECT * FROM capability_records
       WHERE org = $1 AND project = $2
       ORDER BY namespace ASC, action ASC
       LIMIT $3 OFFSET $4`,
      [scope.org, scope.project, limit, offset],
    );

    return rows.map((row) => this.rowToRecord(row));
  }

  /**
   * Increment usage metrics for a capability
   *
   * @param id - The UUID of the capability
   * @param success - Whether execution was successful
   * @param latencyMs - Execution latency in milliseconds
   */
  async recordUsage(
    id: string,
    success: boolean,
    latencyMs: number,
  ): Promise<void> {
    await this.db.query(
      `UPDATE capability_records
       SET
         usage_count = usage_count + 1,
         success_count = success_count + CASE WHEN $2 THEN 1 ELSE 0 END,
         total_latency_ms = total_latency_ms + $3,
         updated_at = NOW()
       WHERE id = $1`,
      [id, success, latencyMs],
    );
  }

  /**
   * Delete a capability by UUID
   *
   * @param id - The UUID of the capability to delete
   * @returns true if deleted, false if not found
   */
  async delete(id: string): Promise<boolean> {
    const result = await this.db.query(
      `DELETE FROM capability_records WHERE id = $1 RETURNING id`,
      [id],
    );
    return result.length > 0;
  }

  /**
   * Convert database row to CapabilityRecord
   */
  private rowToRecord(row: Record<string, unknown>): CapabilityRecord {
    return {
      id: row.id as string,
      org: row.org as string,
      project: row.project as string,
      namespace: row.namespace as string,
      action: row.action as string,
      hash: row.hash as string,
      workflowPatternId: row.workflow_pattern_id as string | undefined,
      createdBy: row.created_by as string,
      createdAt: new Date(row.created_at as string),
      updatedBy: row.updated_by as string | undefined,
      updatedAt: row.updated_at ? new Date(row.updated_at as string) : undefined,
      version: row.version as number,
      versionTag: row.version_tag as string | undefined,
      verified: row.verified as boolean,
      signature: row.signature as string | undefined,
      usageCount: row.usage_count as number,
      successCount: row.success_count as number,
      totalLatencyMs: row.total_latency_ms as number,
      tags: (row.tags as string[]) || [],
      visibility: row.visibility as CapabilityVisibility,
      routing: row.routing as CapabilityRouting,
    };
  }
}

// Helper functions re-exported for convenience
export { getCapabilityDisplayName, getCapabilityFqdn };
