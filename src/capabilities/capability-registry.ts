/**
 * Capability Registry (Story 13.1, Migration 028)
 *
 * Registry for named capabilities with UUID primary key and FQDN components.
 *
 * Architecture: Works with `capability_records` table (migration 021, 028)
 * - UUID is the immutable primary key (used in code as mcp["$cap:<uuid>"])
 * - FQDN is computed from: org.project.namespace.action.hash
 * - Display name is derived from: namespace:action
 *
 * @module capabilities/capability-registry
 */

import type { DbClient } from "../db/types.ts";
import type { CapabilityRecord, CapabilityRouting, CapabilityVisibility, Scope } from "./types.ts";
import { getCapabilityDisplayName, getCapabilityFqdn } from "./types.ts";
import { isValidMCPName } from "./fqdn.ts";
import { resolveRouting } from "./routing-resolver.ts";
import * as log from "@std/log";

// Re-export for convenience
export type { CapabilityRecord, Scope };

/**
 * Input for creating a new capability record
 *
 * Note: code_snippet, description, parameters_schema, tools_used are stored in
 * workflow_pattern table, linked via workflowPatternId FK (migration 023).
 */
export interface CreateCapabilityRecordInput {
  /** Organization */
  org: string;
  /** Project */
  project: string;
  /** Namespace grouping */
  namespace: string;
  /** Action name */
  action: string;
  /** FK to workflow_pattern.pattern_id (required - code lives there) */
  workflowPatternId: string;
  /** Hash for FQDN generation (4 lowercase hex chars) */
  hash: string;
  /** Who is creating this record */
  createdBy?: string;
  /** Optional tags */
  tags?: string[];
  /** Visibility level (default: private) */
  visibility?: CapabilityVisibility;
  /** Explicit routing override (if not set, inferred from toolsUsed) */
  routing?: CapabilityRouting;
  /** Tools used by this capability (Story 13.9 - routing inference) */
  toolsUsed?: string[];
}

/**
 * Capability Registry class
 *
 * Provides methods for:
 * - Creating and registering capabilities with UUID PK
 * - Resolving names by scope (namespace:action)
 * - Looking up by UUID or FQDN components
 */
export class CapabilityRegistry {
  private db: DbClient;

  constructor(db: DbClient) {
    this.db = db;
  }

  /**
   * Create a new capability record with auto-generated UUID
   *
   * Note: Code, description, params, tools are in workflow_pattern via FK.
   *
   * @param input - The capability record data
   * @returns The created record with UUID
   */
  async create(input: CreateCapabilityRecordInput): Promise<CapabilityRecord> {
    // Validate namespace:action for MCP compatibility
    const displayName = `${input.namespace}:${input.action}`;
    if (!isValidMCPName(displayName)) {
      throw new Error(
        `Invalid namespace:action: "${displayName}". Must be alphanumeric with underscores, hyphens, and colons only.`,
      );
    }

    const now = new Date();
    const createdBy = input.createdBy || "local";

    // Insert into database - UUID is auto-generated by DB
    // ON CONFLICT uses unique index on (org, project, namespace, action, hash)
    const result = await this.db.query(
      `
      INSERT INTO capability_records (
        org, project, namespace, action, hash,
        workflow_pattern_id, created_by, created_at, visibility, routing, tags
      ) VALUES (
        $1, $2, $3, $4, $5,
        $6, $7, $8, $9, $10, $11
      )
      ON CONFLICT (org, project, namespace, action, hash) DO UPDATE SET
        workflow_pattern_id = EXCLUDED.workflow_pattern_id,
        updated_by = EXCLUDED.created_by,
        updated_at = NOW(),
        version = capability_records.version + 1,
        tags = EXCLUDED.tags
      RETURNING id
    `,
      [
        input.org,
        input.project,
        input.namespace,
        input.action,
        input.hash,
        input.workflowPatternId,
        createdBy,
        now.toISOString(),
        input.visibility || "private",
        resolveRouting(input.toolsUsed || [], input.routing),
        input.tags || [],
      ],
    );

    const id = result[0]?.id as string;
    if (!id) {
      throw new Error(`Failed to create capability record`);
    }

    // Fetch and return the created record
    const record = await this.getById(id);
    if (!record) {
      throw new Error(`Failed to fetch created capability record: ${id}`);
    }

    const fqdn = getCapabilityFqdn(record);
    log.info(`Created capability record: ${fqdn} (id: ${id})`);
    return record;
  }

  /**
   * Get a capability record by UUID
   *
   * @param id - The UUID primary key
   * @returns The record or null if not found
   */
  async getById(id: string): Promise<CapabilityRecord | null> {
    // JOIN with workflow_pattern to get accurate usage_count/success_count
    // (capability_records columns are never updated - bug found Dec 2024)
    const rows = await this.db.query(
      `SELECT cr.*,
              COALESCE(wp.usage_count, 0) as wp_usage_count,
              COALESCE(wp.success_count, 0) as wp_success_count
       FROM capability_records cr
       LEFT JOIN workflow_pattern wp ON cr.workflow_pattern_id = wp.pattern_id
       WHERE cr.id = $1`,
      [id],
    );

    if (rows.length === 0) {
      return null;
    }

    return this.rowToRecord(rows[0]);
  }

  /**
   * Get a capability record by workflow_pattern_id (foreign key)
   *
   * @param workflowPatternId - The workflow_pattern.pattern_id
   * @returns The record or null if not found
   */
  async getByWorkflowPatternId(workflowPatternId: string): Promise<CapabilityRecord | null> {
    const rows = await this.db.query(
      `SELECT cr.*,
              COALESCE(wp.usage_count, 0) as wp_usage_count,
              COALESCE(wp.success_count, 0) as wp_success_count
       FROM capability_records cr
       LEFT JOIN workflow_pattern wp ON cr.workflow_pattern_id = wp.pattern_id
       WHERE cr.workflow_pattern_id = $1`,
      [workflowPatternId],
    );

    if (rows.length === 0) {
      return null;
    }

    return this.rowToRecord(rows[0]);
  }

  /**
   * Get a capability record by code_hash within a scope
   *
   * Used to prevent duplicate capability_records after rename.
   * Joins with workflow_pattern to check code_hash.
   *
   * @param codeHash - The full code hash from workflow_pattern
   * @param scope - The org/project scope
   * @returns The record or null if not found
   */
  async getByCodeHash(codeHash: string, scope: Scope): Promise<CapabilityRecord | null> {
    const rows = await this.db.query(
      `SELECT cr.*,
              COALESCE(wp.usage_count, 0) as wp_usage_count,
              COALESCE(wp.success_count, 0) as wp_success_count
       FROM capability_records cr
       JOIN workflow_pattern wp ON cr.workflow_pattern_id = wp.pattern_id
       WHERE wp.code_hash = $1
         AND cr.org = $2
         AND cr.project = $3
       LIMIT 1`,
      [codeHash, scope.org, scope.project],
    );

    if (rows.length === 0) {
      return null;
    }

    return this.rowToRecord(rows[0]);
  }

  /**
   * Get a capability record by FQDN components
   *
   * @param org - Organization
   * @param project - Project
   * @param namespace - Namespace
   * @param action - Action
   * @param hash - Hash
   * @returns The record or null if not found
   */
  async getByFqdnComponents(
    org: string,
    project: string,
    namespace: string,
    action: string,
    hash: string,
  ): Promise<CapabilityRecord | null> {
    const rows = await this.db.query(
      `SELECT cr.*,
              COALESCE(wp.usage_count, 0) as wp_usage_count,
              COALESCE(wp.success_count, 0) as wp_success_count
       FROM capability_records cr
       LEFT JOIN workflow_pattern wp ON cr.workflow_pattern_id = wp.pattern_id
       WHERE cr.org = $1 AND cr.project = $2 AND cr.namespace = $3 AND cr.action = $4 AND cr.hash = $5`,
      [org, project, namespace, action, hash],
    );

    if (rows.length === 0) {
      return null;
    }

    return this.rowToRecord(rows[0]);
  }

  /**
   * Resolve a name to a capability record within a scope
   *
   * Resolution order:
   * 1. Match by namespace:action format in current scope
   * 2. Match by action only in current scope (if no colon)
   * 3. Public capability match (visibility = 'public')
   *
   * @param name - The namespace:action or action name to resolve
   * @param scope - The org/project scope
   * @returns The resolved record or null
   */
  async resolveByName(
    name: string,
    scope: Scope,
  ): Promise<CapabilityRecord | null> {
    // Common SELECT with JOIN for accurate usage counts
    const selectCols = `cr.*,
      COALESCE(wp.usage_count, 0) as wp_usage_count,
      COALESCE(wp.success_count, 0) as wp_success_count`;
    const joinClause = `FROM capability_records cr
      LEFT JOIN workflow_pattern wp ON cr.workflow_pattern_id = wp.pattern_id`;

    // 1. Try namespace:action format
    const colonIndex = name.indexOf(":");
    if (colonIndex > 0) {
      const namespace = name.substring(0, colonIndex);
      const action = name.substring(colonIndex + 1);

      const namespaceMatch = await this.db.query(
        `SELECT ${selectCols} ${joinClause}
         WHERE cr.org = $1 AND cr.project = $2 AND cr.namespace = $3 AND cr.action = $4`,
        [scope.org, scope.project, namespace, action],
      );

      if (namespaceMatch.length > 0) {
        return this.rowToRecord(namespaceMatch[0]);
      }
    } else {
      // 2. Try action only (search across all namespaces in scope)
      const actionMatch = await this.db.query(
        `SELECT ${selectCols} ${joinClause}
         WHERE cr.org = $1 AND cr.project = $2 AND cr.action = $3
         LIMIT 1`,
        [scope.org, scope.project, name],
      );

      if (actionMatch.length > 0) {
        return this.rowToRecord(actionMatch[0]);
      }
    }

    // 3. Try public capability match
    if (colonIndex > 0) {
      const namespace = name.substring(0, colonIndex);
      const action = name.substring(colonIndex + 1);

      const publicMatch = await this.db.query(
        `SELECT ${selectCols} ${joinClause}
         WHERE cr.namespace = $1 AND cr.action = $2 AND cr.visibility = 'public'
         LIMIT 1`,
        [namespace, action],
      );

      if (publicMatch.length > 0) {
        return this.rowToRecord(publicMatch[0]);
      }
    }

    return null;
  }

  /**
   * List all capabilities in a scope
   *
   * @param scope - The org/project scope
   * @param limit - Maximum results (default: 100)
   * @param offset - Pagination offset (default: 0)
   * @returns List of capability records
   */
  async listByScope(
    scope: Scope,
    limit = 100,
    offset = 0,
  ): Promise<CapabilityRecord[]> {
    const rows = await this.db.query(
      `SELECT cr.*,
              COALESCE(wp.usage_count, 0) as wp_usage_count,
              COALESCE(wp.success_count, 0) as wp_success_count
       FROM capability_records cr
       LEFT JOIN workflow_pattern wp ON cr.workflow_pattern_id = wp.pattern_id
       WHERE cr.org = $1 AND cr.project = $2
       ORDER BY cr.namespace ASC, cr.action ASC
       LIMIT $3 OFFSET $4`,
      [scope.org, scope.project, limit, offset],
    );

    return rows.map((row) => this.rowToRecord(row));
  }

  /**
   * Increment usage metrics for a capability
   *
   * Updates workflow_pattern table (the single source of truth for usage stats).
   * Migration 034 removed unused columns from capability_records.
   *
   * @param id - The UUID of the capability (capability_records.id)
   * @param success - Whether execution was successful
   * @param latencyMs - Execution latency in milliseconds
   */
  async recordUsage(
    id: string,
    success: boolean,
    latencyMs: number,
  ): Promise<void> {
    // Update workflow_pattern via the FK relationship
    // This is the single source of truth for usage stats
    await this.db.query(
      `UPDATE workflow_pattern wp
       SET
         usage_count = usage_count + 1,
         success_count = success_count + CASE WHEN $2 THEN 1 ELSE 0 END,
         success_rate = (success_count + CASE WHEN $2 THEN 1 ELSE 0 END)::real / (usage_count + 1)::real,
         avg_duration_ms = ((COALESCE(avg_duration_ms, 0) * usage_count) + $3) / (usage_count + 1),
         last_used = NOW()
       FROM capability_records cr
       WHERE cr.workflow_pattern_id = wp.pattern_id
         AND cr.id = $1`,
      [id, success, Math.round(latencyMs)],
    );

    // Also update capability_records.updated_at for tracking
    await this.db.query(
      `UPDATE capability_records SET updated_at = NOW() WHERE id = $1`,
      [id],
    );
  }

  /**
   * Delete a capability by UUID
   *
   * @param id - The UUID of the capability to delete
   * @returns true if deleted, false if not found
   */
  async delete(id: string): Promise<boolean> {
    const result = await this.db.query(
      `DELETE FROM capability_records WHERE id = $1 RETURNING id`,
      [id],
    );
    return result.length > 0;
  }

  /**
   * Convert database row to CapabilityRecord
   *
   * NOTE: Prefer wp_usage_count/wp_success_count from workflow_pattern JOIN
   * over capability_records columns (which were never updated - bug Dec 2024).
   * TODO: Migration to drop unused columns from capability_records.
   */
  private rowToRecord(row: Record<string, unknown>): CapabilityRecord {
    // Use workflow_pattern counts if available (from JOIN), else fallback
    const usageCount = row.wp_usage_count !== undefined
      ? (row.wp_usage_count as number)
      : (row.usage_count as number);
    const successCount = row.wp_success_count !== undefined
      ? (row.wp_success_count as number)
      : (row.success_count as number);

    return {
      id: row.id as string,
      org: row.org as string,
      project: row.project as string,
      namespace: row.namespace as string,
      action: row.action as string,
      hash: row.hash as string,
      workflowPatternId: row.workflow_pattern_id as string | undefined,
      createdBy: row.created_by as string,
      createdAt: new Date(row.created_at as string),
      updatedBy: row.updated_by as string | undefined,
      updatedAt: row.updated_at ? new Date(row.updated_at as string) : undefined,
      version: row.version as number,
      versionTag: row.version_tag as string | undefined,
      verified: row.verified as boolean,
      signature: row.signature as string | undefined,
      usageCount,
      successCount,
      // totalLatencyMs removed in migration 034, use avg_duration_ms from workflow_pattern
      totalLatencyMs: row.total_latency_ms as number | undefined,
      tags: (row.tags as string[]) || [],
      visibility: row.visibility as CapabilityVisibility,
      routing: row.routing as CapabilityRouting,
    };
  }
}

// Helper functions re-exported for convenience
export { getCapabilityDisplayName, getCapabilityFqdn };
