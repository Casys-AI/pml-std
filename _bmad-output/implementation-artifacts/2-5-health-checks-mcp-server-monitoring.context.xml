<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2.5</storyId>
    <title>Health Checks & MCP Server Monitoring</title>
    <status>drafted</status>
    <generatedAt>2025-11-08</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-2.5.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>Casys Intelligence to monitor MCP server health et report issues</iWant>
    <soThat>I know which servers are down or misconfigured</soThat>
    <tasks
    >
      - HealthChecker service implemented
      - Initial health check at startup working
      - Periodic health checks (5 min interval) working
      - Retry logic (3 attempts) implemented
      - `agentcards status` CLI command working
      - Watch mode for real-time monitoring
      - JSON output option for scripting
      - Health status logged to database
      - Integration with gateway (filter down servers)
      - Unit tests passing
      - Documentation updated
      - Code reviewed and merged
    </tasks>
  </story>

  <acceptanceCriteria
  >
    1. Health check implementation au startup (ping chaque MCP server)
    2. Periodic health checks (every 5 minutes) durant runtime
    3. Health status tracking: healthy, degraded, down
    4. Console warnings pour servers unavailable
    5. Automatic retry logic (3 attempts) avant marking server down
    6. Health status API: `agentcards status` CLI command
    7. Logs structured avec server_id, status, last_check timestamp
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - Casys Intelligence</title>
        <section>CLI Commands</section>
        <snippet
        >Story 2.5 defines health checks CLI command: `agentcards status [--verbose]` to show server health, database size, and metrics.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - Casys Intelligence</title>
        <section>Project Structure</section>
        <snippet
        >Health checks command location: src/cli/commands/status.ts. Telemetry module for logging: src/telemetry/logger.ts</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - Casys Intelligence</title>
        <section>Error Handling Pattern</section>
        <snippet
        >Custom error hierarchy with Casys IntelligenceError base class. MCPServerError for server-specific errors. All async operations wrapped in try-catch with structured error logging.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - Casys Intelligence</title>
        <section>Logging Strategy</section>
        <snippet
        >Structured logging with std/log. Log levels: error, warn, info, debug. JSON format for file logs: {timestamp, level, message, context}. Logs destination: console (INFO) and file (~/.agentcards/logs/agentcards.log)</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Functional Requirements</section>
        <snippet
        >FR010: System must perform automatic health checks on MCP servers at startup. FR015: System must generate structured logs for debugging and monitoring.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>User Journey - Setup Casys Intelligence</section>
        <snippet
        >During migration, Casys Intelligence detects 15 MCP servers and displays "15 MCP servers migrés et indexés avec succès". Console shows metrics like "Context usage: 2.3% | Workflow completed in 4.2s"</snippet>
      </doc>
      <doc>
        <path>docs/stories/story-2.4.md</path>
        <title>Story 2.4 - MCP Gateway Integration</title>
        <section>Prerequisites</section>
        <snippet
        >Story 2.4 completed - Gateway integration with Claude Code operational. Gateway server implements stdio transport and exposes tools via MCP protocol.</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>src/mcp/client.ts</path>
        <kind>service</kind>
        <symbol>MCPClient</symbol>
        <lines>28-353</lines>
        <reason
        >MCP client class that will be used by HealthChecker to ping servers. Has listTools() method for health checks and timeout handling.</reason>
      </file>
      <file>
        <path>src/mcp/gateway-server.ts</path>
        <kind>service</kind>
        <symbol>Casys IntelligenceGatewayServer</symbol>
        <lines>60-478</lines>
        <reason
        >Gateway server where HealthChecker will be integrated. Has mcpClients Map and start() method where health checks should be called.</reason>
      </file>
      <file>
        <path>src/telemetry/logger.ts</path>
        <kind>service</kind>
        <symbol>setupLogger, getLogger, logger</symbol>
        <lines>1-164</lines>
        <reason
        >Logging infrastructure to use for structured health check logs. Provides logger.info(), logger.warn(), logger.error() with JSON formatting.</reason>
      </file>
      <file>
        <path>src/mcp/types.ts</path>
        <kind>types</kind>
        <symbol>MCPServer, MCPTool</symbol>
        <lines>All</lines>
        <reason
        >Type definitions for MCP servers and tools. HealthChecker will use MCPServer type and work with MCPClient instances.</reason>
      </file>
    </code>
    <dependencies>
      <runtime>
        <name>Deno</name>
        <version>2.5 / 2.2 LTS</version>
        <usage>Runtime environment, native TypeScript support</usage>
      </runtime>
      <framework>
        <name>@std/log</name>
        <version>0.224.11</version>
        <usage>Structured logging for health check logs</usage>
      </framework>
      <framework>
        <name>@cliffy/command</name>
        <version>1.0.0-rc.7</version>
        <usage>CLI framework for implementing status command</usage>
      </framework>
      <framework>
        <name>@modelcontextprotocol/sdk</name>
        <version>^1.0.4</version>
        <usage>MCP protocol SDK for server communication</usage>
      </framework>
      <testing>
        <name>Deno.test</name>
        <version>Built-in</version>
        <usage>Native Deno testing framework</usage>
      </testing>
      <testing>
        <name>@std/assert</name>
        <version>1.0.11</version>
        <usage>Assertion library for tests</usage>
      </testing>
    </dependencies>
  </artifacts>

  <constraints
  >
    - Health checks MUST NOT block gateway startup - run asynchronously
    - Use existing MCPClient.listTools() method for server ping (don't create new RPC methods)
    - Retry logic: 3 attempts with exponential backoff (1s, 2s, 4s delays)
    - Health check interval: EXACTLY 5 minutes (300000ms) as specified in ACs
    - Structured logs MUST include: server_id, status, last_check timestamp
    - Health status values: "healthy", "degraded", "down" (no other values)
    - Console output: Use console.log() for normal output, console.warn() for warnings
    - File logging: Use logger from src/telemetry/logger.ts for structured logs
    - CLI command name: MUST be "status" (not "health" or other variations)
    - Follow existing naming conventions: kebab-case for files, PascalCase for classes
    - Error handling: Wrap in try-catch, use structured logging, don't throw on individual server failures
    - Integration point: Gateway server start() method must call health checker
  </constraints>
  <interfaces>
    <interface>
      <name>HealthChecker</name>
      <kind>class</kind>
      <signature
      >
        class HealthChecker {
          constructor(mcpClients: Map&lt;string, MCPClient&gt;)
          async initialHealthCheck(): Promise&lt;void&gt;
          startPeriodicChecks(): void
          stopPeriodicChecks(): void
          getServerHealth(serverId: string): ServerHealth | undefined
          getAllHealth(): ServerHealth[]
          getHealthSummary(): { total, healthy, degraded, down }
        }
      </signature>
      <path>src/health/health-checker.ts (to be created)</path>
    </interface>
    <interface>
      <name>ServerHealth</name>
      <kind>interface</kind>
      <signature
      >
        interface ServerHealth {
          serverId: string
          serverName: string
          status: "healthy" | "degraded" | "down"
          lastCheck: Date
          lastSuccess: Date | null
          consecutiveFailures: number
          latencyMs: number | null
          errorMessage: string | null
        }
      </signature>
      <path>src/health/health-checker.ts (to be created)</path>
    </interface>
    <interface>
      <name>MCPClient.listTools()</name>
      <kind>method</kind>
      <signature>async listTools(): Promise&lt;MCPTool[]&gt;</signature>
      <path>src/mcp/client.ts:110-141</path>
    </interface>
  </interfaces>
  <tests>
    <standards
    >
      Testing follows Deno native testing conventions using Deno.test() framework. Test files use .test.ts extension. Assertions via @std/assert. Tests should cover unit, integration, and error scenarios. Mock MCP servers available in tests/mocks/. Success criteria typically include success rates (>=90%), latency targets (P95), and zero crashes. Integration tests should test real MCP client interactions with mocks.
    </standards>
    <locations
    >
      - tests/unit/ - Unit tests for individual components
      - tests/integration/ - Integration tests with dependencies
      - tests/mocks/ - Mock MCP servers for testing
      - tests/validation/ - Validation/smoke tests (see option2-mcp-gateway.test.ts)
    </locations>
    <ideas
    >
      - AC1: Unit test for initialHealthCheck() - verify all servers pinged, console output correct
      - AC2: Unit test for periodic checks - verify setInterval called with 300000ms (5 min)
      - AC3: Integration test for health status tracking - healthy/degraded/down state transitions
      - AC4: Unit test for console warnings - verify warn() called when servers unavailable
      - AC5: Integration test for retry logic - verify 3 attempts with delays (1s, 2s, 4s)
      - AC6: Integration test for CLI status command - verify output format, JSON option, watch mode
      - AC7: Unit test for structured logs - verify server_id, status, last_check in log output
      - Error handling: Test timeout scenarios, connection failures, malformed responses
      - Edge case: All servers down - verify graceful handling and summary display
      - Edge case: Empty mcpClients map - verify health checker handles gracefully
    </ideas>
  </tests>
</story-context>
