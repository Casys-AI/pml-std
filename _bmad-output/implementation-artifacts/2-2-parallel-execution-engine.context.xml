<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2.2</storyId>
    <title>Parallel Execution Engine</title>
    <status>drafted</status>
    <generatedAt>2025-11-05</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-2.2.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>power user</asA>
    <iWant>workflows with independent tools to execute in parallel</iWant>
    <soThat>I save time instead of waiting for sequential execution</soThat>
    <tasks>
      <!-- Tasks derived from Acceptance Criteria -->
      <task id="1">Create ParallelExecutor class in src/dag/executor.ts</task>
      <task id="2">Implement topological sort for DAG layer identification</task>
      <task id="3">Implement Promise.all/allSettled for parallel execution</task>
      <task id="4">Implement sequential execution respecting topological order</task>
      <task id="5">Add partial success handling (continue on task failure)</task>
      <task id="6">Implement results aggregation (successes + errors)</task>
      <task id="7">Add performance measurement and speedup calculation</task>
      <task id="8">Create benchmark tests for parallel vs sequential execution</task>
      <task id="9">Validate P95 latency &lt;3s and 3-5x speedup targets</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Parallel executor module créé (src/dag/executor.ts)</criterion>
    <criterion id="2"
    >DAG traversal avec identification des nodes exécutables en parallèle</criterion>
    <criterion id="3"
    >Promise.all utilisé pour parallel execution de independent branches</criterion>
    <criterion id="4"
    >Sequential execution pour dependent tools (respect topological order)</criterion>
    <criterion id="5">Partial success handling: continue execution même si un tool fail</criterion>
    <criterion id="6">Results aggregation: successes + errors retournés avec codes</criterion>
    <criterion id="7">Performance measurement: latency avant/après parallélisation</criterion>
    <criterion id="8">Target: P95 latency &lt;3 secondes pour workflow 5-tools</criterion>
    <criterion id="9"
    >Benchmarks tests validant 3-5x speedup sur workflows parallélisables</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/architecture.md</path>
        <title>System Architecture</title>
        <section>DAG Execution (Epic 2)</section>
        <snippet
        >Parallel executor module in src/dag/executor.ts for automatic parallelization with 5x speedup. Uses topological sort to identify execution layers and Promise.all for independent branches.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Definitions</title>
        <section>Epic 2: DAG Execution &amp; Production Readiness</section>
        <snippet
        >Story 2.2 delivers parallel execution engine with Promise.all for independent tools, sequential execution respecting topological order, and 3-5x performance improvement.</snippet>
      </doc>
      <doc>
        <path>docs/technical-analysis-dag-strategy.md</path>
        <title>DAG Strategy Analysis</title>
        <section>Parallel Execution Patterns</section>
        <snippet
        >Gateway performs topological sort, identifies parallel execution layers, uses Promise.allSettled for resilience. No dependencies means all tools run in parallel, partial dependencies yield mixed parallel/sequential execution.</snippet>
      </doc>
      <doc>
        <path>docs/stories/story-2.1.md</path>
        <title>Story 2.1: GraphRAG Engine with Graphology</title>
        <section>DAG Builder Implementation</section>
        <snippet
        >GraphRAGEngine.buildDAG() constructs DAG from tool candidates using graph topology. Returns DAGStructure with tasks and dependencies based on shortest paths (&lt;=3 hops).</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Performance Targets</section>
        <snippet
        >Target 5x speedup through parallel execution. P95 latency under 3 seconds for 5-tool workflows. Zero-config automatic parallelization.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/graphrag/types.ts</path>
        <kind>interfaces</kind>
        <symbol>Task, DAGStructure, ExecutionResult</symbol>
        <lines>10-55</lines>
        <reason
        >Core DAG types already defined. ParallelExecutor must use these interfaces for consistency with GraphRAGEngine.</reason>
      </artifact>
      <artifact>
        <path>src/graphrag/graph-engine.ts</path>
        <kind>class</kind>
        <symbol>GraphRAGEngine.buildDAG()</symbol>
        <lines>193-220</lines>
        <reason
        >Existing DAG builder. ParallelExecutor receives DAGStructure from this method and must execute it respecting topology.</reason>
      </artifact>
      <artifact>
        <path>src/graphrag/dag-suggester.ts</path>
        <kind>class</kind>
        <symbol>DAGSuggester</symbol>
        <lines>1-162</lines>
        <reason
        >Generates DAG suggestions with confidence scoring. ParallelExecutor will execute the suggested DAG structures.</reason>
      </artifact>
      <artifact>
        <path>src/mcp/gateway-handler.ts</path>
        <kind>class</kind>
        <symbol>GatewayHandler</symbol>
        <lines>1-304</lines>
        <reason
        >Handles workflow execution modes. Will integrate ParallelExecutor to execute DAGs in suggestion and speculative modes.</reason>
      </artifact>
      <artifact>
        <path>tests/unit/graphrag/graph_engine_test.ts</path>
        <kind>test</kind>
        <symbol>GraphRAGEngine tests</symbol>
        <lines>1-400</lines>
        <reason
        >Example test patterns for graph operations. Parallel executor tests should follow similar structure.</reason>
      </artifact>
    </code>
    <dependencies>
      <deno>
        <package>@std/assert</package>
        <version>1.0.11</version>
        <usage>Testing assertions</usage>
      </deno>
      <native>
        <feature>Promise.all / Promise.allSettled</feature>
        <usage>Parallel task execution within layers</usage>
      </native>
      <native>
        <feature>performance.now()</feature>
        <usage>Execution time measurement for benchmarking</usage>
      </native>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint
    >Must use existing DAGStructure and Task interfaces from src/graphrag/types.ts - do not create new types</constraint>
    <constraint
    >Must integrate with GraphRAGEngine.buildDAG() output - executor receives pre-built DAG, does not build it</constraint>
    <constraint
    >Must use Promise.allSettled (not Promise.all) for resilience - partial failures should not block entire layer</constraint>
    <constraint
    >Topological sort must detect circular dependencies and throw error before execution</constraint>
    <constraint>Performance requirement: P95 latency &lt;3 seconds for 5-tool workflows</constraint>
    <constraint
    >Performance requirement: 3-5x speedup vs sequential execution for parallelizable workflows</constraint>
    <constraint>Must support $OUTPUT[task_id] reference resolution in task arguments</constraint>
    <constraint
    >Failed tasks marked as error status but execution continues for independent tasks</constraint>
    <constraint>TypeScript strict mode enabled - all types must be explicit</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>ParallelExecutor.execute()</name>
      <kind>class method</kind>
      <signature>async execute(dag: DAGStructure): Promise&lt;ExecutionResult&gt;</signature>
      <path>src/dag/executor.ts (to be created)</path>
      <description
      >Main execution entry point. Takes DAG structure, performs topological sort, executes layers in parallel, returns aggregated results with timing.</description>
    </interface>
    <interface>
      <name>DAGStructure</name>
      <kind>interface</kind>
      <signature>interface DAGStructure { tasks: Task[] }</signature>
      <path>src/graphrag/types.ts</path>
      <description
      >Input format for executor. Array of tasks with dependencies already defined.</description>
    </interface>
    <interface>
      <name>Task</name>
      <kind>interface</kind>
      <signature
      >interface Task { id: string; tool: string; arguments: Record&lt;string, unknown&gt;; depends_on: string[] }</signature>
      <path>src/graphrag/types.ts</path>
      <description
      >Individual task representation with tool reference and dependency list.</description>
    </interface>
    <interface>
      <name>ExecutionResult (aggregate)</name>
      <kind>interface</kind>
      <signature
      >interface ExecutionResult { results: TaskResult[]; executionTimeMs: number; parallelizationLayers: number; errors: TaskError[] }</signature>
      <path>src/dag/executor.ts (to be created)</path>
      <description
      >Return value containing all task results, timing metrics, layer count, and error details.</description>
    </interface>
  </interfaces>

  <tests>
    <standards
    >Deno test framework with @std/assert. Tests located in tests/unit/ for unit tests and tests/benchmark/ for performance tests. Use Deno.test() with descriptive names. Follow AAA pattern (Arrange, Act, Assert). Mock MCP clients for testing.</standards>
    <locations>
      <location>tests/unit/dag/executor_test.ts</location>
      <location>tests/benchmark/parallel_execution_bench.ts</location>
    </locations>
    <ideas>
      <idea ac="1">Test ParallelExecutor class instantiation and basic structure</idea>
      <idea ac="2"
      >Test topological sort correctly identifies parallel layers: [t1,t2] -&gt; [t3] -&gt; [t4,t5]</idea>
      <idea ac="3"
      >Test Promise.allSettled execution: verify all tasks in a layer execute simultaneously</idea>
      <idea ac="4">Test sequential execution: verify dependent tasks wait for dependencies</idea>
      <idea ac="5"
      >Test partial success: one task fails, verify execution continues for independent tasks</idea>
      <idea ac="6"
      >Test results aggregation: verify both successes and errors returned with correct structure</idea>
      <idea ac="7"
      >Test performance measurement: verify executionTimeMs and calculateSpeedup() accuracy</idea>
      <idea ac="8"
      >Benchmark test: 5 independent tasks @100ms each should complete in ~100ms (not 500ms)</idea>
      <idea ac="9"
      >Benchmark test: verify 3-5x speedup on parallelizable workflows vs sequential baseline</idea>
      <idea ac="10">Test $OUTPUT reference resolution: task2 uses output from task1</idea>
      <idea ac="11"
      >Test circular dependency detection: DAG with cycle should throw before execution</idea>
      <idea ac="12">Test error propagation: dependent task should fail if dependency failed</idea>
    </ideas>
  </tests>
</story-context>
