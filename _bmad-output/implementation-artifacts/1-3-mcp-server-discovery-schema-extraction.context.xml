<?xml version="1.0" encoding="UTF-8"?>
<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>1.3</storyId>
    <title>MCP Server Discovery & Schema Extraction</title>
    <status>drafted</status>
    <generatedAt>2025-11-04</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-1.3.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>power user with 15+ MCP servers</asA>
    <iWant
    >Casys Intelligence to automatically discover my MCP servers and extract their tool schemas</iWant>
    <soThat>I don't have to manually configure each server</soThat>
    <tasks>
      <task id="1"
      >Implement MCPServerDiscovery class with config file parsing and server detection</task>
      <task id="2">Implement connection establishment to stdio and SSE MCP servers</task>
      <task id="3">Implement list_tools MCP protocol call and schema extraction</task>
      <task id="4">Implement JSON Schema validation for tool input/output schemas</task>
      <task id="5">Implement schema storage to PGlite tool_schema table</task>
      <task id="6">Implement error handling for unreachable servers and invalid schemas</task>
      <task id="7">Implement console output showing discovery and extraction summary</task>
      <task id="8">Test discovery and schema extraction with 15+ simulated MCP servers</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">MCP server discovery via stdio et SSE protocols</criterion>
    <criterion id="AC2">Connection établie avec chaque discovered server</criterion>
    <criterion id="AC3">Tool schemas extracted via MCP protocol `list_tools` call</criterion>
    <criterion id="AC4">Schemas parsed et validated (input/output schemas, descriptions)</criterion>
    <criterion id="AC5">Schemas stockés dans PGlite `tool_schema` table</criterion>
    <criterion id="AC6">Error handling pour servers unreachable ou invalid schemas</criterion>
    <criterion id="AC7"
    >Console output affiche nombre de servers discovered et tools extracted</criterion>
    <criterion id="AC8">Support au minimum 15 MCP servers simultanément</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PRD.md</path>
        <title>Casys Intelligence Product Requirements Document</title>
        <section>Requirements - MCP Server Management</section>
        <snippet
        >FR009: Le système doit auto-découvrir les MCP servers disponibles (stdio et SSE) sans configuration manuelle. FR010: Le système doit effectuer des health checks automatiques sur les MCP servers au démarrage. FR011: Le système doit supporter 15+ MCP servers actifs simultanément sans dégradation de performance.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - Casys Intelligence</title>
        <section>Project Structure - src/mcp/</section>
        <snippet
        >src/mcp/ module contains: discovery.ts (Story 1.3 - Server discovery), client.ts (MCP SDK wrapper), gateway.ts (Story 2.4 - Gateway server), types.ts (MCP type definitions). Story 1.3 focuses on auto-discovering servers and extracting schemas via list_tools protocol call.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - Casys Intelligence</title>
        <section>Technology Stack Details - MCP Integration</section>
        <snippet
        >MCP Integration: @modelcontextprotocol/sdk (official), stdio transport (primary), SSE transport (optional). MCP servers commonly use stdio (Claude Code default). Process management via Deno.Command for stdio subprocess communication. External Systems: MCP Servers (15+) via stdio subprocess.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - Casys Intelligence</title>
        <section>Data Architecture - Database Schema</section>
        <snippet
        >Database schema includes: tool_schema table (tool_id PRIMARY KEY, server_id, name, description, input_schema JSONB, output_schema JSONB, cached_at TIMESTAMPTZ). Story 1.3 populates this table via schema extraction from MCP servers.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 1 - Stories 1.1 through 1.8</section>
        <snippet
        >Epic 1 delivers Foundation & Context Optimization. Story 1.3 (MCP Server Discovery) follows Story 1.2 (PGlite Database). Discovery enables schema extraction which feeds into story 1.4 (embeddings generation) and story 1.5 (semantic search).</snippet>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>src/db/client.ts</path>
        <kind>module</kind>
        <symbol>PGliteClient</symbol>
        <lines>1-150</lines>
        <reason
        >Story 1.3 AC5 requires storing schemas in PGlite. PGliteClient provides the database interface. MCPServerDiscovery will call db.exec() and db.query() to store extracted schemas in tool_schema table.</reason>
      </artifact>
      <artifact>
        <path>deno.json</path>
        <kind>config</kind>
        <symbol>imports</symbol>
        <lines>23-29</lines>
        <reason
        >Contains @modelcontextprotocol/sdk import (Story 1.3 AC3 requires MCP protocol calls). Also includes @std/log for logging, @std/fs for config file reading.</reason>
      </artifact>
      <artifact>
        <path>src/</path>
        <kind>directory</kind>
        <symbol>mcp/</symbol>
        <lines>N/A</lines>
        <reason
        >Story 1.3 creates src/mcp/discovery.ts module for server discovery implementation. Directory structure already exists from project setup (Story 1.1).</reason>
      </artifact>
      <artifact>
        <path>src/db/migrations.ts</path>
        <kind>module</kind>
        <symbol>createInitialMigration</symbol>
        <lines>110-178</lines>
        <reason
        >Creates tool_schema table that story 1.3 populates. AC5 requires storage in tool_schema table with columns: tool_id, server_id, name, description, input_schema, output_schema.</reason>
      </artifact>
    </code>

    <dependencies>
      <ecosystem name="Deno">
        <runtime version="2.5 / 2.2 LTS">Deno runtime for CLI and subprocess management</runtime>
        <stdlib version="0.224.0">
          <package>std/log - Structured logging for discovery operations and errors</package>
          <package>std/fs - File system operations for reading config.yaml</package>
          <package>std/yaml - YAML parsing for MCP server configuration</package>
        </stdlib>
      </ecosystem>
      <ecosystem name="NPM (via Deno npm: specifier)">
        <package name="@modelcontextprotocol/sdk" version="latest"
        >Official MCP TypeScript SDK for protocol communication, list_tools calls</package>
      </ecosystem>
      <note
      >Story 1.3 does NOT add new dependencies beyond what Story 1.1-1.2 already imported. Uses existing @modelcontextprotocol/sdk from deno.json imports. Subprocess communication via native Deno.Command (built-in).</note>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="runtime"
    >Deno 2.5 (latest) or 2.2 (LTS) - TypeScript 5.7+ via Deno, ES2022 target</constraint>
    <constraint type="mcp_protocol"
    >MCP stdio transport (primary, required for AC1-AC3). SSE transport optional (deferred to later). Must implement list_tools JSON-RPC call as per MCP specification.</constraint>
    <constraint type="discovery"
    >Discovery must read MCP server configuration from file (e.g., ~/.agentcards/config.yaml or ~/.config/Claude/claude_desktop_config.json). Parse server definitions: id, name, command, args, env, protocol.</constraint>
    <constraint type="schema_validation"
    >Input/output schemas must be valid JSON Schema (can be partial). Store as JSONB in tool_schema table. Handle missing output_schema (optional field).</constraint>
    <constraint type="error_handling"
    >Per AC6: Must handle unreachable servers (timeout after 10s), invalid schemas (schema parse failures), and malformed responses. Continue with other servers on individual failures (graceful degradation).</constraint>
    <constraint type="concurrency"
    >Per AC8: Must support 15+ servers simultaneously. Use async/await with proper Promise management (not sequential). Max 10s timeout per server.</constraint>
    <constraint type="database"
    >Must use existing PGliteClient from src/db/client.ts. Insert/update tool_schema table. Handle duplicate tool_id (upsert: ON CONFLICT DO UPDATE). Transactions recommended for batch inserts.</constraint>
    <constraint type="logging"
    >Per AC7: Console output must show: servers discovered (count), successfully connected (count with tool counts), failed servers (count with error summary), total tools extracted. Use @std/log with INFO level for console output.</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>MCPServer</name>
      <kind>TypeScript interface</kind>
      <signature
      >
interface MCPServer {
  id: string;           // Unique server identifier
  name: string;         // Human-readable name
  command: string;      // Executable command (e.g., "python", "node")
  args?: string[];      // Command arguments (e.g., ["-m", "mcp.server"])
  env?: Record&lt;string, string&gt;;  // Environment variables
  protocol: "stdio" | "sse";  // Transport protocol
}
      </signature>
      <path>src/mcp/discovery.ts</path>
    </interface>

    <interface>
      <name>ToolSchema (MCP Tool)</name>
      <kind>MCP Protocol interface</kind>
      <signature
      >
// From MCP Protocol: Response to list_tools call
interface Tool {
  name: string;                    // Tool identifier (e.g., "read_file")
  description: string;             // Tool description
  inputSchema: JSONSchema;         // Input schema (required)
  outputSchema?: JSONSchema;       // Output schema (optional)
}
      </signature>
      <path>From @modelcontextprotocol/sdk</path>
    </interface>

    <interface>
      <name>ServerDiscoveryResult</name>
      <kind>TypeScript interface</kind>
      <signature
      >
interface ServerDiscoveryResult {
  serverId: string;
  serverName: string;
  status: "success" | "failed" | "timeout";
  toolsExtracted: number;
  tools?: Tool[];
  error?: string;  // Error message if status is "failed" or "timeout"
  connectionDuration?: number;  // Milliseconds
}
      </signature>
      <path>src/mcp/discovery.ts</path>
    </interface>

    <interface>
      <name>MCPClientConnection</name>
      <kind>MCP SDK interface</kind>
      <signature
      >
// From @modelcontextprotocol/sdk
interface Client {
  listTools(): Promise&lt;{ tools: Tool[] }&gt;;
  close(): Promise&lt;void&gt;;
}

// Story 1.3 must create Client connection via:
// - StdioClientTransport for stdio servers
// - SSEClientTransport for SSE servers
      </signature>
      <path>From @modelcontextprotocol/sdk</path>
    </interface>
  </interfaces>

  <tests>
    <standards
    >
      Story 1.3 tests must be written using Deno.test() framework. Test strategy: Unit tests for discovery and schema extraction logic, integration tests for database storage, and load tests for 15+ simultaneous servers. Test files must be co-located with source (src/mcp/discovery_test.ts). Target coverage: >80% of discovery code paths including happy path and error scenarios (timeouts, invalid servers, malformed schemas). Mock MCP servers can be simulated in test fixtures using stdio subprocess mocking or in-memory implementations. All tests must pass with deno task test and include timeout handling verification (10s per server).
    </standards>

    <locations>
      <location>tests/unit/mcp/discovery_test.ts</location>
      <location>tests/integration/mcp_discovery_integration_test.ts</location>
      <location>tests/fixtures/mock_mcp_servers/</location>
    </locations>

    <ideas>
      <test-idea criterion="AC1"
      >Test MCP server discovery: Parse mock config.yaml with 5 stdio servers, verify discovery identifies all servers and their protocols</test-idea>
      <test-idea criterion="AC1"
      >Test SSE protocol detection: Parse config with mixed stdio and SSE servers, verify protocol correctly identified</test-idea>
      <test-idea criterion="AC2"
      >Test stdio connection: Mock stdio subprocess, verify successful connection and handshake</test-idea>
      <test-idea criterion="AC2"
      >Test SSE connection: Mock SSE endpoint, verify HTTP connection and event stream setup</test-idea>
      <test-idea criterion="AC2"
      >Test connection timeout: Simulate unresponsive server, verify 10s timeout triggers and connection fails gracefully</test-idea>
      <test-idea criterion="AC3"
      >Test list_tools call: Mock server response with 5 tools, verify list_tools JSON-RPC call sent and response parsed</test-idea>
      <test-idea criterion="AC4"
      >Test schema validation: Valid input/output schemas in JSON Schema format, verify parsed without errors</test-idea>
      <test-idea criterion="AC4"
      >Test invalid schema handling: Malformed JSON Schema, verify validation fails and error is captured</test-idea>
      <test-idea criterion="AC5"
      >Test schema storage: Insert 10 tools from mock server into tool_schema table, verify all inserted with correct columns</test-idea>
      <test-idea criterion="AC5"
      >Test upsert behavior: Insert same tool twice, verify ON CONFLICT UPDATE works (second insert updates cached_at)</test-idea>
      <test-idea criterion="AC6"
      >Test error handling - unreachable server: Cannot connect to server, verify error logged and other servers continue</test-idea>
      <test-idea criterion="AC6"
      >Test error handling - invalid schema: Server returns tool with missing inputSchema, verify error captured and other tools processed</test-idea>
      <test-idea criterion="AC7"
      >Test console output: Run discovery with 3 servers (2 success, 1 failure), verify console shows "Found 3 servers, connected to 2, 1 failed"</test-idea>
      <test-idea criterion="AC8"
      >Test concurrent servers: Simulate 15 servers with varied response times, verify all processed concurrently (not sequential), total time ~10s (max single timeout)</test-idea>
      <test-idea criterion="AC8"
      >Test scalability: Simulate 20 servers, verify no degradation, all 20 processed within 10s timeout window</test-idea>
    </ideas>
  </tests>
</story-context>
