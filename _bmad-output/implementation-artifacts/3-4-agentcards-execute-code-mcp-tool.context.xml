<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.4</storyId>
    <title>agentcards:execute_code MCP Tool</title>
    <status>drafted</status>
    <generatedAt>2025-11-20</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-3.4.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>Epic 2.5 ControlledExecutor</asA>
    <iWant>to delegate code execution tasks to an isolated sandbox with DAG integration</iWant>
    <soThat
    >I can orchestrate hybrid workflows combining MCP tools and code execution with checkpoint/rollback support</soThat>
    <tasks>
      <phase id="1" name="MCP Tool Registration" estimatedHours="1-2">
        <task id="1" acs="1,2,5,7">
          <title>Define tool schema and register in gateway</title>
          <subtasks>
            <subtask>Créer schema JSON pour agentcards:execute_code</subtask>
            <subtask
            >Input: { code: string, intent?: string, context?: object, sandbox_config?: object }</subtask>
            <subtask
            >Output: { result: unknown, logs: string[], metrics: object, state?: object }</subtask>
            <subtask>Modifier src/mcp/gateway-server.ts</subtask>
            <subtask>Ajouter agentcards:execute_code dans list_tools response</subtask>
            <subtask>Créer handler handleExecuteCode() dans gateway</subtask>
            <subtask>Router tool call vers sandbox executor</subtask>
          </subtasks>
        </task>
      </phase>
      <phase id="2" name="Intent-Based &amp; Explicit Modes" estimatedHours="2">
        <task id="2" acs="3,4">
          <title>Implement intent-based and explicit execution modes</title>
          <subtasks>
            <subtask>Intent-based: utiliser vector search pour tools pertinents</subtask>
            <subtask>Injecter top-k tools dans code context (via Story 3.2)</subtask>
            <subtask>Explicit mode: utiliser context directement sans vector search</subtask>
            <subtask>Supporter mix: intent + context custom</subtask>
          </subtasks>
        </task>
      </phase>
      <phase id="3" name="DAG Integration" estimatedHours="2-3">
        <task id="3" acs="8,9,10,11">
          <title>Integrate code execution as DAG task type</title>
          <subtasks>
            <subtask>Ajouter type "code_execution" à src/dag/types.ts TaskType enum</subtask>
            <subtask>Modifier ControlledExecutor pour exécuter code_execution tasks</subtask>
            <subtask>Router vers sandbox executor avec config appropriée</subtask>
            <subtask>Intégrer résultats dans WorkflowState via reducers</subtask>
            <subtask>Checkpoint compatible: sauvegarder état dans PGlite</subtask>
          </subtasks>
        </task>
      </phase>
      <phase id="4" name="Error Handling &amp; Isolation Foundation" estimatedHours="1-2">
        <task id="4" acs="6,12,13,14">
          <title>Error handling and rollback foundation</title>
          <subtasks>
            <subtask>Capturer syntax errors, runtime errors, timeout errors</subtask>
            <subtask>Format MCP-compliant error responses</subtask>
            <subtask>Préparer hooks pour virtual filesystem (ou implémentation basique)</subtask>
            <subtask>Rollback support: permettre abort sans side-effects</subtask>
            <subtask>Marquer code_execution tasks comme idempotent (safe-to-fail)</subtask>
          </subtasks>
        </task>
      </phase>
      <phase id="5" name="Example Workflow &amp; Documentation" estimatedHours="1">
        <task id="5" acs="15,16">
          <title>Documentation and example workflows</title>
          <subtasks>
            <subtask>Créer test E2E: ControlledExecutor → DAG → code task → checkpoint</subtask>
            <subtask>README section: Epic 2.5 delegation patterns</subtask>
            <subtask>Exemples: Intent-based vs Explicit mode</subtask>
            <subtask>Best practices: When to use code execution in DAG workflows</subtask>
          </subtasks>
        </task>
      </phase>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">New MCP tool registered: agentcards:execute_code</criterion>
    <criterion id="2"
    >Input schema: { code: string, intent?: string, context?: object, sandbox_config?: object }</criterion>
    <criterion id="3"
    >Intent-based mode: vector search → inject relevant tools → execute code</criterion>
    <criterion id="4">Explicit mode: Execute provided code with specified context</criterion>
    <criterion id="5"
    >Output schema: { result: any, logs: string[], metrics: object, state?: object }</criterion>
    <criterion id="6">Error handling: Syntax errors, runtime errors, timeout errors</criterion>
    <criterion id="7">Integration with gateway: Tool appears in list_tools response</criterion>
    <criterion id="8">DAG task type: Add code_execution type to src/dag/types.ts</criterion>
    <criterion id="9"
    >ControlledExecutor integration: Execute code_execution tasks via sandbox</criterion>
    <criterion id="10">Checkpoint compatible: Results structured for PGlite persistence</criterion>
    <criterion id="11"
    >State management: Results integrated into WorkflowState via reducers</criterion>
    <criterion id="12"
    >Virtual filesystem hooks: Prepare for isolated FS (or basic implementation)</criterion>
    <criterion id="13">Rollback support: Execution can be aborted without side-effects</criterion>
    <criterion id="14"
    >Safe-to-fail foundation: Code execution tasks marked as idempotent</criterion>
    <criterion id="15"
    >Example workflow: ControlledExecutor builds DAG → executes code task → checkpoint saved</criterion>
    <criterion id="16">Documentation: README updated with Epic 2.5 delegation patterns</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/adrs/ADR-007-dag-adaptive-feedback-loops.md</path>
        <title>ADR-007: DAG Adaptatif avec Feedback Loops</title>
        <section>Epic 3 Délégation &amp; Checkpoint Architecture</section>
        <snippet
        >Epic 2.5 délègue modifications de code à Epic 3 sandbox executor. Checkpoints sauvegardent orchestration state uniquement. Epic 3 résout limitations via filesystem isolé, rollback natif, speculation safe, checkpoint light.</snippet>
      </doc>
      <doc>
        <path>docs/stories/story-3.1.md</path>
        <title>Story 3.1: Deno Sandbox Executor Foundation</title>
        <section>Acceptance Criteria &amp; Implementation</section>
        <snippet
        >Sandbox validé avec 512MB heap, 30s timeout, &lt;100ms startup. DenoSandboxExecutor.execute(code) API disponible. Isolation complète, structured errors, JSON-serializable results.</snippet>
      </doc>
      <doc>
        <path>docs/stories/story-3.2.md</path>
        <title>Story 3.2: MCP Tools Injection</title>
        <section>Context Builder &amp; Tool Wrapping</section>
        <snippet
        >ContextBuilder.buildContext(tools) génère wrappers TypeScript. Vector search identifie tools pertinents depuis intent. Tool calls routés via existing MCP gateway.</snippet>
      </doc>
      <doc>
        <path>docs/stories/story-2.5-3.md</path>
        <title>Story 2.5-3: AIL/HIL Integration &amp; DAG Replanning</title>
        <section>ControlledExecutor &amp; WorkflowState</section>
        <snippet
        >ControlledExecutor exécute DAG avec event stream, command queue, checkpoints. WorkflowState avec reducers (messages, tasks, decisions, context). DAGSuggester.replanDAG() pour modification dynamique.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture</title>
        <section>Epic 3 Overview</section>
        <snippet
        >Code execution inspiré approche Anthropic. Vector search (Epic 1) découvre tools, puis code execution traite résultats localement. Agent écrit code au lieu d'appeler tools directement.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/sandbox/executor.ts</path>
        <kind>service</kind>
        <symbol>DenoSandboxExecutor</symbol>
        <lines>1-300</lines>
        <reason
        >Core sandbox executor. Will be called by execute_code tool to run agent-generated code with timeout/memory limits.</reason>
      </artifact>
      <artifact>
        <path>src/sandbox/context-builder.ts</path>
        <kind>service</kind>
        <symbol>ContextBuilder</symbol>
        <lines>1-200</lines>
        <reason
        >Tool injection system. Used for intent-based mode to inject MCP tools into sandbox context.</reason>
      </artifact>
      <artifact>
        <path>src/sandbox/types.ts</path>
        <kind>types</kind>
        <symbol>SandboxConfig, ExecutionResult, StructuredError</symbol>
        <lines>1-103</lines>
        <reason
        >Sandbox type definitions. ExecutionResult will be extended with state field for checkpoint compatibility.</reason>
      </artifact>
      <artifact>
        <path>src/dag/types.ts</path>
        <kind>types</kind>
        <symbol>TaskResult, DAGExecutionResult, ExecutorConfig</symbol>
        <lines>1-99</lines>
        <reason>DAG task types. Need to add "code_execution" to TaskType enum for AC #8.</reason>
      </artifact>
      <artifact>
        <path>src/dag/controlled-executor.ts</path>
        <kind>service</kind>
        <symbol>ControlledExecutor</symbol>
        <lines>1-400</lines>
        <reason
        >Epic 2.5 executor with event stream, checkpoints, state management. Will execute code_execution tasks via sandbox.</reason>
      </artifact>
      <artifact>
        <path>src/dag/state.ts</path>
        <kind>types</kind>
        <symbol>WorkflowState, reducers</symbol>
        <lines>1-150</lines>
        <reason
        >State management with reducers. Code execution results will be integrated via add_tasks reducer.</reason>
      </artifact>
      <artifact>
        <path>src/mcp/gateway-server.ts</path>
        <kind>service</kind>
        <symbol>MCPGatewayServer</symbol>
        <lines>1-300</lines>
        <reason>MCP gateway server. Will register execute_code tool and handle tool calls.</reason>
      </artifact>
      <artifact>
        <path>src/vector/search.ts</path>
        <kind>service</kind>
        <symbol>VectorSearch</symbol>
        <lines>1-200</lines>
        <reason
        >Vector search for intent-based mode. Identifies relevant tools from natural language intent.</reason>
      </artifact>
    </code>
    <dependencies>
      <deno>
        <package name="@std/assert" version="1.0.11" scope="testing" />
        <package name="@std/fs" version="1.0.19" scope="filesystem" />
        <package name="@std/log" version="0.224.14" scope="logging" />
      </deno>
      <npm>
        <package name="@modelcontextprotocol/sdk" version="^1.0.4" scope="MCP protocol" />
        <package name="@electric-sql/pglite" version="0.3.11" scope="checkpoint persistence" />
      </npm>
      <runtime>
        <package name="Deno" version="2.5 / 2.2 LTS" scope="runtime" />
      </runtime>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint
    >Epic 2.5 Delegation: This tool is the primary delegation point from ControlledExecutor to sandbox. Must integrate seamlessly with DAG execution flow.</constraint>
    <constraint
    >Checkpoint Compatibility: Results must be structured for PGlite persistence. Include state field in output for WorkflowState integration.</constraint>
    <constraint
    >Safe-to-Fail: Code execution tasks are idempotent and can be rolled back. No permanent side-effects (filesystem isolation).</constraint>
    <constraint
    >Virtual Filesystem: Prepare hooks or basic implementation for isolated filesystem. Full implementation may come in later story.</constraint>
    <constraint
    >MCP Protocol Compliance: Input/output schemas must follow MCP tool specification. Error responses must be MCP-compliant.</constraint>
    <constraint
    >Performance: Maintain &lt;100ms sandbox startup (Story 3.1), total execution &lt;30s timeout, intent-based tool discovery &lt;200ms.</constraint>
    <constraint
    >Security: All code runs in isolated sandbox with explicit permissions. No eval() or dynamic code generation in tool injection.</constraint>
    <constraint
    >Testing: Integration tests must validate full DAG workflow (ControlledExecutor → code_execution task → checkpoint → resume).</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>agentcards:execute_code MCP Tool</name>
      <kind>MCP tool</kind>
      <signature
      >{ code: string, intent?: string, context?: object, sandbox_config?: object } → { result: any, logs: string[], metrics: object, state?: object }</signature>
      <path>src/mcp/gateway-server.ts</path>
      <note
      >Primary interface for Epic 2.5 delegation. Intent triggers vector search, context provides explicit data, sandbox_config controls execution.</note>
    </interface>
    <interface>
      <name>DenoSandboxExecutor.execute()</name>
      <kind>method</kind>
      <signature
      >async execute(code: string, context?: Record&lt;string, unknown&gt;): Promise&lt;ExecutionResult&gt;</signature>
      <path>src/sandbox/executor.ts</path>
      <note
      >Called by execute_code tool. Will be extended to return state field for checkpoint compatibility.</note>
    </interface>
    <interface>
      <name>ContextBuilder.buildContext()</name>
      <kind>method</kind>
      <signature
      >async buildContext(tools: ToolMetadata[]): Promise&lt;Record&lt;string, unknown&gt;&gt;</signature>
      <path>src/sandbox/context-builder.ts</path>
      <note>Used in intent-based mode to inject MCP tools into sandbox context.</note>
    </interface>
    <interface>
      <name>TaskType enum</name>
      <kind>enum extension</kind>
      <signature>type TaskType = "mcp_tool" | "code_execution"</signature>
      <path>src/dag/types.ts</path>
      <note
      >Must add "code_execution" variant for AC #8. Enables ControlledExecutor to route to sandbox.</note>
    </interface>
    <interface>
      <name>WorkflowState</name>
      <kind>interface</kind>
      <signature
      >{ messages: Message[], tasks: TaskResult[], decisions: Decision[], context: Record&lt;string, any&gt;, checkpoint_id?: string }</signature>
      <path>src/dag/state.ts</path>
      <note
      >Code execution results integrated via add_tasks reducer. State field from ExecutionResult merged into WorkflowState.context.</note>
    </interface>
    <interface>
      <name>ControlledExecutor.executeStream()</name>
      <kind>method</kind>
      <signature
      >async *executeStream(dag: DAGStructure): AsyncGenerator&lt;ExecutionEvent&gt;</signature>
      <path>src/dag/controlled-executor.ts</path>
      <note
      >Will route code_execution tasks to sandbox executor. Integrates results into state and emits checkpoint events.</note>
    </interface>
  </interfaces>
  <tests>
    <standards
    >Project uses Deno.test framework with @std/assert. Testing strategy: unit tests (tests/unit/), integration tests (tests/integration/), E2E tests (tests/e2e/). Target coverage &gt;80%. Integration tests validate full DAG workflows with checkpoints. E2E tests simulate Epic 2.5 delegation scenarios.</standards>
    <locations>
      <location>tests/integration/code_execution_tool_test.ts</location>
      <location>tests/integration/gateway_code_exec_test.ts</location>
      <location>tests/e2e/controlled_executor_code_exec_test.ts</location>
      <location>tests/unit/mcp/execute_code_handler_test.ts</location>
    </locations>
    <ideas>
      <idea acs="1,2,5,7"
      >Unit test: Tool registration in gateway, schema validation, list_tools includes execute_code, input/output schema compliance.</idea>
      <idea acs="3"
      >Integration test: Intent-based mode - provide intent → vector search triggered → relevant tools injected → code executes with tools available.</idea>
      <idea acs="4"
      >Integration test: Explicit mode - provide context object → no vector search → code executes with explicit context.</idea>
      <idea acs="6"
      >Unit test: Error handling - syntax error in code, runtime error during execution, timeout exceeded, MCP-compliant error responses.</idea>
      <idea acs="8,9"
      >Integration test: DAG task type - ControlledExecutor builds DAG with code_execution task → executor routes to sandbox → result returned.</idea>
      <idea acs="10,11"
      >E2E test: Checkpoint workflow - DAG with code_execution task → execute layer → checkpoint saved → validate state in PGlite → resume from checkpoint.</idea>
      <idea acs="12,13,14"
      >Integration test: Rollback - execute code_execution task → abort mid-execution → verify no side-effects, idempotent re-execution.</idea>
      <idea acs="15"
      >E2E test: Full Epic 2.5 delegation - ControlledExecutor builds hybrid DAG (MCP tools + code_execution) → parallel execution → checkpoint → results integrated in WorkflowState.</idea>
      <idea acs="16"
      >Documentation test: Verify README examples are executable and produce expected results.</idea>
      <idea
      >Performance test: Intent-based tool discovery &lt;200ms, sandbox startup &lt;100ms, total execution for simple code &lt;500ms.</idea>
      <idea
      >Security test: Verify sandbox isolation - code cannot access filesystem outside allowed paths, no network access, timeout enforcement.</idea>
    </ideas>
  </tests>
</story-context>
