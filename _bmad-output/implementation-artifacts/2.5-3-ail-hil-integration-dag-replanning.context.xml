<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2.5</epicId>
    <storyId>2.5.3</storyId>
    <title>Agent-in-the-Loop (AIL) / Human-in-the-Loop (HIL) Integration + DAG Replanning</title>
    <status>drafted</status>
    <generatedAt>2025-11-14</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-2.5-3.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer building adaptive AI workflows</asA>
    <iWant>agent and human decision points integrated into DAG execution with dynamic replanning capability</iWant>
    <soThat>workflows can adapt in real-time to discoveries, get human approval for critical operations, and self-improve through GraphRAG feedback loops</soThat>
    <tasks>
### Task 1: Agent-in-the-Loop (AIL) Decision Points (1-1.5h)
- Subtask 1.1: Add AIL configuration to ExecutionConfig
- Subtask 1.2: Implement AIL decision point in executeStream()
- Subtask 1.3: Extend CommandQueue with AIL commands
- Subtask 1.4: Agent sees all MCP results (verify no filtering)
- Subtask 1.5: Unit tests for AIL

### Task 2: Human-in-the-Loop (HIL) Approval Checkpoints (1h)
- Subtask 2.1: Add HIL configuration to ExecutionConfig
- Subtask 2.2: Implement HIL checkpoint logic
- Subtask 2.3: Generate summary for human display (500-1000 tokens)
- Subtask 2.4: Process HIL responses
- Subtask 2.5: Integration tests for HIL

### Task 3: DAG Replanning with GraphRAG (1-1.5h)
- Subtask 3.1: Implement DAGSuggester.replanDAG() method
- Subtask 3.2: Merge new nodes with existing DAG
- Subtask 3.3: Integrate replanDAG() into ControlledExecutor
- Subtask 3.4: Performance validation
- Subtask 3.5: Unit tests for DAG replanning

### Task 4: GraphRAG Feedback Loop (1h)
- Subtask 4.1: Implement GraphRAGEngine.updateFromExecution()
- Subtask 4.2: Update knowledge graph edges in PGlite
- Subtask 4.3: Recompute PageRank with new data
- Subtask 4.4: Integrate updateFromExecution() into ControlledExecutor
- Subtask 4.5: Integration tests for feedback loop

### Task 5: End-to-End Integration Tests (0.5-1h)
- Subtask 5.1: E2E Test: AIL Workflow (agent triggers replan)
- Subtask 5.2: E2E Test: HIL Workflow (human approves/rejects)
- Subtask 5.3: E2E Test: Dynamic DAG Replanning (discovery pattern)
- Subtask 5.4: E2E Test: GraphRAG Update Verification
</tasks>
  </story>

  <acceptanceCriteria>
### AC-3.1: Agent-in-the-Loop (AIL) ✅
- ✅ AIL decision points configurable (per_layer, on_error, manual)
- ✅ `decision_required` event emitted with context
- ✅ Agent sees all MCP results (no filtering, natural conversation)
- ✅ Agent can enqueue commands (continue, replan, abort)

### AC-3.2: Human-in-the-Loop (HIL) ✅
- ✅ HIL approval checkpoints configurable (always, critical_only, never)
- ✅ Summary generated for human (500-1000 tokens)
- ✅ Human response via `checkpoint_response` command
- ✅ Human decisions logged to `decisions[]` array

### AC-3.3: DAG Replanning ✅
- ✅ `DAGSuggester.replanDAG()` method implemented
- ✅ Queries GraphRAG for new tools (vector search + PageRank)
- ✅ Merges new nodes with existing DAG structure
- ✅ Replan completes <200ms P95

### AC-3.4: GraphRAG Feedback Loop ✅
- ✅ `GraphRAGEngine.updateFromExecution()` called on workflow completion
- ✅ Tool co-occurrence patterns extracted
- ✅ Edge weights updated in knowledge graph
- ✅ PageRank recomputed with new data

### AC-3.5: Multi-Turn State ✅
- ✅ `messages[]` array persists conversation history
- ✅ Agent/human messages logged with timestamps
- ✅ Multi-turn state survives checkpoint/resume
- ✅ Conversation context available for AIL decisions

### AC-3.6: Integration Tests ✅
- ✅ End-to-end AIL workflow (agent triggers replan)
- ✅ End-to-end HIL workflow (human approves/rejects)
- ✅ Dynamic DAG replanning scenario (discovery pattern)
- ✅ GraphRAG update verification (edge weights changed)
</acceptanceCriteria>

  <artifacts>
    <docs>
      <!-- Primary Technical Specifications -->
      <doc>
        <path>docs/tech-spec-epic-2.5.md</path>
        <title>Epic Technical Specification: Adaptive DAG Feedback Loops (Foundation)</title>
        <section>Overview + Detailed Design</section>
        <snippet>Epic 2.5 établit la fondation pour workflows adaptatifs via une architecture 3-Loop Learning: Loop 1 (Execution) fournit observabilité temps réel via event stream; Loop 2 (Adaptation) permet AIL/HIL avec re-planification dynamique du DAG; Loop 3 (Meta-Learning) enrichit le knowledge graph avec patterns d'exécution.</snippet>
      </doc>

      <doc>
        <path>docs/adrs/ADR-007-dag-adaptive-feedback-loops.md</path>
        <title>ADR-007: DAG Adaptatif avec Feedback Loops AIL/HIL et Re-planification Dynamique</title>
        <section>Context + Decision + Critical Distinction</section>
        <snippet>Context Management: Un seul agent en conversation continue (pas de filtering contexte). Agent voit TOUS les MCP results. GraphRAG (Knowledge Graph) = Source de vérité permanente. DAG (Workflow Graph) = Plan d'exécution éphémère. Replanning = DAGSuggester requête GraphRAG pour trouver nouveaux tools.</snippet>
      </doc>

      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture - Pattern 4: 3-Loop Learning Architecture</title>
        <section>Novel Pattern Designs + Integration Points</section>
        <snippet>Architecture hybride combinant LangGraph MessagesState (reducers automatiques) avec Event-Driven patterns (observability complète). Score 95/100 après analyse comparative. PGlite persistence, Graphology pour graph computations.</snippet>
      </doc>

      <!-- Story Dependencies -->
      <doc>
        <path>docs/stories/story-2.5-2.md</path>
        <title>Story 2.5-2: Checkpoint & Resume Infrastructure</title>
        <section>Learnings from Previous Story</section>
        <snippet>CheckpointManager intégré via setCheckpointManager(). Performance exceptionnelle P95=0.50ms (100x mieux que target). Async operations non-bloquantes. Reducers automatiques fonctionnent parfaitement. State serialization/deserialization éprouvée. Security patterns: parameterized queries, state validation, error sanitization.</snippet>
      </doc>

      <doc>
        <path>docs/stories/story-2.5-1.md</path>
        <title>Story 2.5-1: Controlled Executor Foundation</title>
        <section>EventStream + CommandQueue + WorkflowState Implementation</section>
        <snippet>ControlledExecutor extends ParallelExecutor (zero breaking changes). EventStream = TransformStream for real-time observability. CommandQueue = AsyncQueue for dynamic control. WorkflowState avec MessagesState-inspired reducers (messages, tasks, decisions, context).</snippet>
      </doc>

      <!-- Product & Business Context -->
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document - Epic 2.5</title>
        <section>Epic 2.5 - Adaptive DAG Feedback Loops (Foundation)</section>
        <snippet>Open Core Freemium model. Zero new external dependencies philosophy. Performance targets: speedup 5x preserved, checkpoint overhead &lt;50ms, replan latency &lt;200ms P95.</snippet>
      </doc>
    </docs>

    <code>
      <!-- Existing Components to Modify -->
      <artifact>
        <path>src/dag/controlled-executor.ts</path>
        <kind>class</kind>
        <symbol>ControlledExecutor</symbol>
        <lines>1-99+</lines>
        <reason>Main executor class - Extend with AIL/HIL decision points logic, handleReplanCommand() method, and GraphRAG feedback loop integration after workflow completion</reason>
      </artifact>

      <artifact>
        <path>src/dag/types.ts</path>
        <kind>types</kind>
        <symbol>ExecutionEvent, Command</symbol>
        <lines>83-231</lines>
        <reason>Type definitions for events and commands - Already has decision_required event type (line 137-142) and command types. May need to extend with AIL/HIL specific command types (continue, abort, checkpoint_response)</reason>
      </artifact>

      <artifact>
        <path>src/dag/state.ts</path>
        <kind>module</kind>
        <symbol>WorkflowState, Decision, Message</symbol>
        <lines>1-79+</lines>
        <reason>State management with reducers - Already has Decision type (line 22-29) and messages[] array. Reducers ready to append AIL/HIL decisions. Multi-turn conversation state persists automatically</reason>
      </artifact>

      <artifact>
        <path>src/dag/command-queue.ts</path>
        <kind>class</kind>
        <symbol>CommandQueue</symbol>
        <lines>1-100+</lines>
        <reason>Command queue for dynamic control - Extend to process new AIL/HIL commands (continue, abort, checkpoint_response). AsyncQueue pattern already handles non-blocking command injection</reason>
      </artifact>

      <artifact>
        <path>src/dag/event-stream.ts</path>
        <kind>class</kind>
        <symbol>EventStream</symbol>
        <lines>1-100+</lines>
        <reason>Event stream for observability - Use to emit decision_required events for AIL/HIL checkpoints. TransformStream API already supports &lt;5ms emission overhead</reason>
      </artifact>

      <!-- GraphRAG Components to Extend -->
      <artifact>
        <path>src/graphrag/dag-suggester.ts</path>
        <kind>class</kind>
        <symbol>DAGSuggester</symbol>
        <lines>1-79+</lines>
        <reason>DAG suggestion engine - Add replanDAG() method to query GraphRAG for new tools during runtime. Existing suggestDAG() provides pattern for vector search + PageRank ranking + DAG construction</reason>
      </artifact>

      <artifact>
        <path>src/graphrag/graph-engine.ts</path>
        <kind>class</kind>
        <symbol>GraphRAGEngine</symbol>
        <lines>1-79+</lines>
        <reason>GraphRAG knowledge graph engine - Implement updateFromExecution() method to extract tool co-occurrence patterns, update PGlite edges, and recompute PageRank. Existing syncFromDatabase() pattern shows graph sync workflow</reason>
      </artifact>

      <!-- Checkpoint Infrastructure (Story 2.5-2) -->
      <artifact>
        <path>src/dag/checkpoint-manager.ts</path>
        <kind>class</kind>
        <symbol>CheckpointManager</symbol>
        <lines>1-100+</lines>
        <reason>Checkpoint persistence - Already integrated in ControlledExecutor via setCheckpointManager(). CheckpointManager handles PGlite persistence with 5 checkpoints retention. Performance proven: P95=0.50ms</reason>
      </artifact>
    </code>

    <dependencies>
      <node>
        <package name="@std/assert" version="1.0.11" scope="dev">Testing assertions</package>
        <package name="@std/log" version="0.224.14">Logging framework</package>
        <package name="@electric-sql/pglite" version="0.3.11">Embedded PostgreSQL database</package>
        <package name="@electric-sql/pglite/vector" version="0.3.11">Vector extension for PGlite</package>
        <package name="graphology" version="^0.25.4">Graph data structure library</package>
        <package name="graphology-metrics" version="^2.2.0">Graph algorithms (PageRank)</package>
        <package name="graphology-shortest-path" version="^2.0.2">Path finding algorithms</package>
        <package name="graphology-communities-louvain" version="^2.0.1">Community detection</package>
      </node>

      <frameworks>
        <framework>Deno 2.x (TypeScript runtime)</framework>
        <framework>PGlite (embedded PostgreSQL for persistence)</framework>
        <framework>Graphology (graph algorithms library)</framework>
      </frameworks>
    </dependencies>
  </artifacts>

  <constraints>
    <!-- Architecture Constraints -->
    <constraint>
      <type>architecture</type>
      <rule>Zero breaking changes - Extend existing ControlledExecutor, don't modify ParallelExecutor</rule>
      <rationale>Backward compatibility requirement from ADR-007. Existing code must continue to work</rationale>
    </constraint>

    <constraint>
      <type>architecture</type>
      <rule>Un seul agent en conversation continue - Pas de context filtering, pas de summarization pour agent</rule>
      <rationale>ADR-007 Context Management Decision: Agent voit TOUS les MCP results dans sa conversation naturelle. Summary généré UNIQUEMENT pour HIL (affichage UI humain)</rationale>
    </constraint>

    <constraint>
      <type>architecture</type>
      <rule>GraphRAG (Knowledge Graph) vs DAG (Workflow Graph) distinction - DAGSuggester re-queries GraphRAG pour replanning</rule>
      <rationale>GraphRAG = Source de vérité permanente pour tools. DAG = Plan éphémère pour workflow actuel. Replanning = Query GraphRAG → Inject new nodes</rationale>
    </constraint>

    <!-- Performance Constraints -->
    <constraint>
      <type>performance</type>
      <rule>Speedup 5x preserved - Parallel execution maintained across all layers</rule>
      <rationale>Critical performance requirement. AIL/HIL decision points must be async and non-blocking</rationale>
    </constraint>

    <constraint>
      <type>performance</type>
      <rule>DAG replan latency &lt;200ms P95 - Vector search + PageRank + merge must be fast</rule>
      <rationale>Tech-Spec Epic 2.5 performance budget. User-facing operation, perceived latency critical</rationale>
    </constraint>

    <constraint>
      <type>performance</type>
      <rule>GraphRAG update &lt;300ms - Feedback loop must not block workflow completion</rule>
      <rationale>Fire-and-forget async operation. Log errors but don't fail workflow if update fails</rationale>
    </constraint>

    <!-- Security Constraints -->
    <constraint>
      <type>security</type>
      <rule>Parameterized SQL queries only - NO string concatenation in PGlite queries</rule>
      <rationale>Learned from Story 2.5-2. Use $1, $2 placeholders to prevent SQL injection</rationale>
    </constraint>

    <constraint>
      <type>security</type>
      <rule>Summary sanitization - Strip sensitive data from HIL summaries (no credentials, no PII)</rule>
      <rationale>Human-facing summaries may be logged or displayed. Must not leak sensitive information</rationale>
    </constraint>

    <constraint>
      <type>security</type>
      <rule>Command validation - Type guards for all commands (continue, abort, replan_dag, checkpoint_response)</rule>
      <rationale>Runtime validation of command payloads. Prevent malformed commands from crashing executor</rationale>
    </constraint>

    <constraint>
      <type>security</type>
      <rule>Rate limiting - Max 3 replans per workflow to prevent resource exhaustion</rule>
      <rationale>Prevent agent from triggering infinite replan loops or overwhelming GraphRAG</rationale>
    </constraint>

    <!-- Testing Constraints -->
    <constraint>
      <type>testing</type>
      <rule>Unit tests &gt;80% coverage - All new code must have comprehensive unit tests</rule>
      <rationale>Quality standard from Tech-Spec Epic 2.5. Focus on reducers, decision logic, DAG merge algorithms</rationale>
    </constraint>

    <constraint>
      <type>testing</type>
      <rule>Integration tests required - E2E AIL, HIL, replanning, and GraphRAG update workflows</rule>
      <rationale>AC-3.6 requirement. Must verify complete adaptive feedback loops work end-to-end</rationale>
    </constraint>

    <!-- External Dependencies Constraints -->
    <constraint>
      <type>dependencies</type>
      <rule>Zero new external dependencies - Use existing stack (TypeScript, Deno, PGlite, Graphology)</rule>
      <rationale>Epic 2.5 philosophy. All AIL/HIL logic pure TypeScript, summary generation via string templates (no LLM calls)</rationale>
    </constraint>
  </constraints>

  <interfaces>
    <!-- ControlledExecutor Extended API -->
    <interface>
      <name>ControlledExecutor.executeStream()</name>
      <kind>async generator</kind>
      <signature>async *executeStream(dag: DAGStructure, workflow_id?: string): AsyncGenerator&lt;ExecutionEvent, WorkflowState, void&gt;</signature>
      <path>src/dag/controlled-executor.ts</path>
      <description>Main execution loop - Extend with AIL/HIL decision points after layer execution. Emit decision_required events, wait for commands via CommandQueue</description>
    </interface>

    <interface>
      <name>DAGSuggester.replanDAG()</name>
      <kind>method (NEW)</kind>
      <signature>async replanDAG(currentDAG: DAGStructure, context: { completedTasks: TaskResult[], newRequirement: string, availableContext: Record&lt;string, any&gt; }): Promise&lt;DAGStructure&gt;</signature>
      <path>src/graphrag/dag-suggester.ts</path>
      <description>NEW method for Story 2.5-3 - Query GraphRAG for new tools, merge with existing DAG, return augmented structure. Used during AIL replan command handling</description>
    </interface>

    <interface>
      <name>GraphRAGEngine.updateFromExecution()</name>
      <kind>method (NEW)</kind>
      <signature>async updateFromExecution(execution: WorkflowExecution): Promise&lt;void&gt;</signature>
      <path>src/graphrag/graph-engine.ts</path>
      <description>NEW method for Story 2.5-3 - Extract tool co-occurrence patterns from executed DAG, update PGlite edges, recompute PageRank. Called after workflow completion (fire-and-forget)</description>
    </interface>

    <interface>
      <name>ExecutionEvent.decision_required</name>
      <kind>event type</kind>
      <signature>{ type: "decision_required", timestamp: number, workflow_id: string, decision_type: "AIL" | "HIL", description: string }</signature>
      <path>src/dag/types.ts</path>
      <description>Already defined (line 137-142) - Emitted when AIL or HIL decision needed. Agent/human responds via CommandQueue</description>
    </interface>

    <interface>
      <name>Command.continue / abort / checkpoint_response</name>
      <kind>command types (EXTEND)</kind>
      <signature>{ type: "abort", reason: string } | { type: "checkpoint_response", checkpoint_id: string, decision: "continue" | "rollback" | "modify", modifications?: ... }</signature>
      <path>src/dag/types.ts</path>
      <description>Command types exist (line 198-231) - May need to add explicit "continue" command type. checkpoint_response already defined for HIL approval</description>
    </interface>

    <interface>
      <name>WorkflowState.decisions[]</name>
      <kind>reducer-managed field</kind>
      <signature>decisions: Decision[] where Decision = { type: "AIL" | "HIL", timestamp: number, description: string, outcome: string, confidence?: number, metadata?: ... }</signature>
      <path>src/dag/state.ts</path>
      <description>Already defined (line 22-29) - Reducer automatically appends AIL/HIL decisions. Multi-turn state persists across checkpoints</description>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Deno testing framework (@std/assert) avec unit tests dans tests/unit/ et integration tests dans tests/integration/.

      Patterns établis:
      - Unit tests: Mocks pour PGlite, ToolExecutor, GraphRAG dependencies
      - Integration tests: In-memory PGlite database, real async workflows
      - Chaos testing: Inject crashes/errors, verify graceful degradation
      - Performance benchmarks: deno bench pour mesurer latencies (replan &lt;200ms, feedback &lt;300ms)

      Security testing: SQL injection attempts (parameterized queries), malformed commands (type guards), rate limiting validation.

      Assertion patterns: assertEquals, assertExists, assertRejects, assertStrictEquals for type safety.
    </standards>

    <locations>
      tests/unit/dag/ - Unit tests for ControlledExecutor AIL/HIL logic, CommandQueue, EventStream
      tests/unit/graphrag/ - Unit tests for DAGSuggester.replanDAG(), GraphRAGEngine.updateFromExecution()
      tests/integration/dag/ - Integration tests for E2E AIL/HIL workflows, checkpoint integration
      tests/benchmarks/ - Performance benchmarks for replan latency, GraphRAG update latency
    </locations>

    <ideas>
      <!-- AC-3.1: AIL Unit Tests -->
      <test ac="AC-3.1" type="unit">Test AIL decision point emitted per_layer - Verify decision_required event with decision_type="AIL" emitted after each layer when config.ail.decision_points="per_layer"</test>
      <test ac="AC-3.1" type="unit">Test AIL decision point emitted on_error - Verify decision_required event emitted when task fails and config.ail.decision_points="on_error"</test>
      <test ac="AC-3.1" type="unit">Test continue command processed - Agent enqueues { type: "continue" }, execution proceeds to next layer</test>
      <test ac="AC-3.1" type="unit">Test abort command halts execution - Agent enqueues { type: "abort", reason: "..." }, workflow stops gracefully</test>
      <test ac="AC-3.1" type="unit">Test AIL decisions logged to WorkflowState.decisions[] - Verify reducer appends decision with type="AIL", timestamp, outcome</test>

      <!-- AC-3.2: HIL Unit Tests -->
      <test ac="AC-3.2" type="unit">Test HIL checkpoint emitted when approval_required="always" - Verify decision_required event with decision_type="HIL" and summary (500-1000 tokens)</test>
      <test ac="AC-3.2" type="unit">Test HIL checkpoint skipped when approval_required="never" - No decision_required event emitted, execution continues</test>
      <test ac="AC-3.2" type="unit">Test summary generation (500-1000 tokens) - Template-based summary includes layer, tasks, results, next layer preview</test>
      <test ac="AC-3.2" type="unit">Test approved checkpoint_response continues execution - Human responds { approved: true }, workflow proceeds</test>
      <test ac="AC-3.2" type="unit">Test rejected checkpoint_response aborts workflow - Human responds { approved: false }, workflow stops with error</test>

      <!-- AC-3.3: DAG Replanning Unit Tests -->
      <test ac="AC-3.3" type="unit">Test replanDAG() returns augmented DAG - Query GraphRAG, find 3-5 tools, merge with current DAG, return new structure</test>
      <test ac="AC-3.3" type="unit">Test new nodes merged correctly (no cycles) - Topological sort succeeds, no circular dependencies introduced</test>
      <test ac="AC-3.3" type="unit">Test completed layers preserved - Layers 0 to current_layer not modified, only future layers augmented</test>
      <test ac="AC-3.3" type="unit">Test replan_dag command triggers replanning - ControlledExecutor handles command, calls DAGSuggester.replanDAG(), updates layers</test>
      <test ac="AC-3.3" type="benchmark">Benchmark replan latency &lt;200ms P95 - Measure vectorSearch + PageRank + merge time, verify under target</test>

      <!-- AC-3.4: GraphRAG Feedback Loop Unit Tests -->
      <test ac="AC-3.4" type="unit">Test updateFromExecution() extracts co-occurrence edges - Given DAG with A→B→C, extract edges [(A,B), (B,C)]</test>
      <test ac="AC-3.4" type="unit">Test edge weights incremented in PGlite - Existing edge observed_count++, confidence_score capped at 1.0</test>
      <test ac="AC-3.4" type="unit">Test PageRank recomputed - Load updated graph, call pagerank(), store new scores</test>
      <test ac="AC-3.4" type="integration">Test updateFromExecution() called on workflow completion - ControlledExecutor finally block triggers update (async, non-blocking)</test>
      <test ac="AC-3.4" type="integration">Test feedback loop doesn't block completion - Workflow completes even if GraphRAG update fails (logged error, not thrown)</test>

      <!-- AC-3.6: E2E Integration Tests -->
      <test ac="AC-3.6" type="integration">E2E AIL workflow - Agent discovers XML files, triggers replan, XML parser injected, execution continues with augmented DAG</test>
      <test ac="AC-3.6" type="integration">E2E HIL workflow - Human approval required before final layer, human approves/rejects, workflow completes/aborts accordingly</test>
      <test ac="AC-3.6" type="integration">E2E dynamic replanning - list_directory finds XML → Agent replan → parse_xml added → Parallel execution (speedup 5x)</test>
      <test ac="AC-3.6" type="integration">E2E GraphRAG update verification - Execute workflow A→B→C, verify edges created, execute similar workflow, verify suggestDAG() uses updated graph</test>
    </ideas>
  </tests>
</story-context>
