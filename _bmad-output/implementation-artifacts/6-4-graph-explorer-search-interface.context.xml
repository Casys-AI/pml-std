<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context for 6.4: Graph Explorer & Search Interface
  Generated: 2025-12-03
  Purpose: Provide comprehensive context for AI agents implementing this story
-->
<story-context version="1.0">
  <!-- ========================================== -->
  <!-- METADATA -->
  <!-- ========================================== -->
  <metadata>
    <story-id>6.4</story-id>
    <story-title>Graph Explorer &amp; Search Interface</story-title>
    <epic-id>6</epic-id>
    <epic-title>Real-time Graph Monitoring &amp; Observability</epic-title>
    <status>drafted</status>
    <estimated-effort>3-4 hours</estimated-effort>
    <context-generated>2025-12-03T00:00:00Z</context-generated>
  </metadata>

  <!-- ========================================== -->
  <!-- USER STORY -->
  <!-- ========================================== -->
  <user-story>
    <as-a>user</as-a>
    <i-want>to search and explore the graph interactively</i-want>
    <so-that>I can find specific tools and understand their relationships</so-that>
  </user-story>

  <!-- ========================================== -->
  <!-- ACCEPTANCE CRITERIA -->
  <!-- ========================================== -->
  <acceptance-criteria>
    <criterion id="AC1">
      <description>Search input avec autocomplete (tool names, servers)</description>
      <testable>true</testable>
    </criterion>
    <criterion id="AC2">
      <description>Search met en surbrillance les nodes matchant</description>
      <testable>true</testable>
    </criterion>
    <criterion id="AC3">
      <description>"Find neighbors" - affiche outils connectés à N hops</description>
      <testable>true</testable>
    </criterion>
    <criterion id="AC4">
      <description>Path finder: chemin le plus court entre deux outils</description>
      <testable>true</testable>
    </criterion>
    <criterion id="AC5">
      <description>Export subgraph (sélection de nodes) en JSON ou DOT format</description>
      <testable>true</testable>
    </criterion>
    <criterion id="AC6">
      <description>Keyboard shortcuts: "/" pour focus search, Escape pour clear</description>
      <testable>true</testable>
    </criterion>
    <criterion id="AC7">
      <description>Search history local (dernières 10 recherches)</description>
      <testable>true</testable>
    </criterion>
    <criterion id="AC8">
      <description>Tests: search, neighbors, path finder retournent résultats corrects</description>
      <testable>true</testable>
    </criterion>
  </acceptance-criteria>

  <!-- ========================================== -->
  <!-- PREREQUISITES -->
  <!-- ========================================== -->
  <prerequisites>
    <prerequisite status="done">
      <id>6.1</id>
      <title>Real-time Events Stream (SSE)</title>
      <provides>SSE infrastructure, EventTarget in GraphRAGEngine, graph events</provides>
    </prerequisite>
    <prerequisite status="done">
      <id>6.2</id>
      <title>Interactive Graph Visualization Dashboard</title>
      <provides
      >Fresh dashboard, Cytoscape.js graph rendering, node/edge styling, GraphVisualization island</provides>
    </prerequisite>
    <prerequisite status="done">
      <id>6.3</id>
      <title>Live Metrics &amp; Analytics Panel</title>
      <provides>MetricsPanel island, Chart.js integration, responsive layout</provides>
    </prerequisite>
  </prerequisites>

  <!-- ========================================== -->
  <!-- EXISTING CODEBASE CONTEXT -->
  <!-- ========================================== -->
  <codebase-context>
    <!-- Fresh Web Application Structure -->
    <directory path="src/web/">
      <description>Fresh 2.0 web application with islands architecture</description>
      <file path="src/web/routes/dashboard.tsx">
        <purpose>Main dashboard route with graph visualization and metrics</purpose>
        <patterns>
          <pattern>SSR route with page() handler</pattern>
          <pattern>CSS-in-JS using style tag in Head</pattern>
          <pattern>Chart.js and Cytoscape.js loaded via CDN</pattern>
          <pattern>Layout: flex with graph-section and metrics panel sidebar</pattern>
        </patterns>
        <dependencies>
          <dep>GraphVisualization island</dep>
          <dep>MetricsPanel island</dep>
        </dependencies>
      </file>
      <file path="src/web/islands/GraphVisualization.tsx">
        <purpose>Interactive Cytoscape.js graph rendering with SSE real-time updates</purpose>
        <exports>
          <export>GraphVisualization (default)</export>
        </exports>
        <state>
          <item>containerRef - Cytoscape container</item>
          <item>cyRef - Cytoscape instance reference</item>
          <item>selectedNode - Currently selected node data</item>
          <item>servers - Set of unique server names</item>
          <item>hiddenServers - Set of filtered servers</item>
        </state>
        <cytoscape-api>
          <method>cy.add() - Add nodes/edges</method>
          <method>cy.$id() - Select element by ID</method>
          <method>cy.nodes() - Get all nodes</method>
          <method>cy.edges() - Get all edges</method>
          <method>cy.layout() - Run layout algorithm</method>
          <method>node.addClass() / removeClass() - Style classes</method>
          <method>node.neighborhood() - Get connected elements</method>
        </cytoscape-api>
        <events>
          <event type="tap">Node/background click handler</event>
          <event type="SSE:edge_created">Add new edge dynamically</event>
          <event type="SSE:edge_updated">Update edge confidence</event>
        </events>
        <line-references>
          <ref line="37-52">Server color mapping</ref>
          <ref line="54-143">Cytoscape initialization with styles</ref>
          <ref line="147-158">Node click handler</ref>
          <ref line="171-209">SSE event handlers</ref>
          <ref line="232-270">loadGraphData function</ref>
          <ref line="281-313">toggleServer filter function</ref>
        </line-references>
      </file>
      <file path="src/web/islands/MetricsPanel.tsx">
        <purpose>Live metrics display with charts and export functionality</purpose>
        <patterns>
          <pattern>Polling every 5s + SSE updates</pattern>
          <pattern>Date range selector</pattern>
          <pattern>CSV export via Blob</pattern>
          <pattern>Collapsible panel</pattern>
        </patterns>
      </file>
    </directory>

    <!-- GraphRAG Engine -->
    <directory path="src/graphrag/">
      <file path="src/graphrag/graph-engine.ts">
        <purpose>Core graph operations with Graphology</purpose>
        <existing-methods>
          <method>getGraphSnapshot() - Returns all nodes/edges for visualization</method>
          <method>getStats() - Node/edge counts</method>
          <method>getDensity() - Graph density calculation</method>
          <method>getTopPageRank(n) - Top N tools by PageRank</method>
          <method>getCommunitiesCount() - Louvain community count</method>
          <method>getMetrics(range) - Comprehensive metrics for dashboard</method>
          <method>searchToolsHybrid() - Semantic + graph search (ADR-022)</method>
        </existing-methods>
        <graphology-imports>
          <import>graphology - Main graph library</import>
          <import>graphology-metrics - PageRank, centrality</import>
          <import>graphology-shortest-path - Dijkstra, BFS</import>
          <import>graphology-communities-louvain - Community detection</import>
        </graphology-imports>
        <methods-to-add>
          <method name="getNeighborsAtDepth">
            <signature>getNeighborsAtDepth(toolId: string, depth: number): string[]</signature>
            <description>Get all tools within N hops of given tool</description>
            <library>graphology BFS traversal</library>
          </method>
          <method name="getShortestPath">
            <signature
            >getShortestPath(fromToolId: string, toToolId: string): string[] | null</signature>
            <description>Find shortest path between two tools using Dijkstra</description>
            <library>graphology-shortest-path</library>
          </method>
          <method name="searchNodes">
            <signature
            >searchNodes(query: string): Array&lt;{id: string, label: string, server: string}&gt;</signature>
            <description>Search nodes by name/server prefix matching for autocomplete</description>
          </method>
        </methods-to-add>
      </file>
    </directory>

    <!-- Gateway Server -->
    <file path="src/mcp/gateway-server.ts">
      <purpose>HTTP/MCP gateway with API endpoints</purpose>
      <existing-endpoints>
        <endpoint method="GET" path="/dashboard">Serve Fresh dashboard</endpoint>
        <endpoint method="GET" path="/api/graph/snapshot">Graph data for visualization</endpoint>
        <endpoint method="GET" path="/api/metrics">Metrics for analytics panel</endpoint>
        <endpoint method="GET" path="/events/stream">SSE event stream</endpoint>
      </existing-endpoints>
      <endpoints-to-add>
        <endpoint method="GET" path="/api/graph/search">
          <query-params>q=string</query-params>
          <description>Search nodes by name/server for autocomplete</description>
        </endpoint>
        <endpoint method="GET" path="/api/graph/neighbors">
          <query-params>tool_id=string, depth=number</query-params>
          <description>Get neighbors at N hops</description>
        </endpoint>
        <endpoint method="GET" path="/api/graph/path">
          <query-params>from=string, to=string</query-params>
          <description>Find shortest path between tools</description>
        </endpoint>
      </endpoints-to-add>
    </file>
  </codebase-context>

  <!-- ========================================== -->
  <!-- INTERFACE DEFINITIONS -->
  <!-- ========================================== -->
  <interfaces>
    <!-- Search Result -->
    <interface name="SearchResult">
      <property name="id" type="string">Tool ID (e.g., "mcp__filesystem__read_file")</property>
      <property name="label" type="string">Tool display name</property>
      <property name="server" type="string">MCP server name</property>
      <property name="score" type="number" optional="true">Relevance score (0-1)</property>
    </interface>

    <!-- Neighbors Response -->
    <interface name="NeighborsResponse">
      <property name="center_tool" type="string">Starting tool ID</property>
      <property name="depth" type="number">Search depth (hops)</property>
      <property name="neighbors" type="string[]">List of neighbor tool IDs</property>
      <property name="subgraph" type="object" optional="true">Subgraph data for export</property>
    </interface>

    <!-- Path Response -->
    <interface name="PathResponse">
      <property name="from" type="string">Source tool ID</property>
      <property name="to" type="string">Target tool ID</property>
      <property name="path" type="string[] | null"
      >Ordered list of tool IDs or null if no path</property>
      <property name="length" type="number">Number of hops (-1 if no path)</property>
    </interface>

    <!-- Subgraph Export -->
    <interface name="SubgraphExport">
      <property name="format" type="'json' | 'dot'">Export format</property>
      <property name="nodes" type="Array">Selected nodes with attributes</property>
      <property name="edges" type="Array">Edges between selected nodes</property>
    </interface>
  </interfaces>

  <!-- ========================================== -->
  <!-- IMPLEMENTATION GUIDE -->
  <!-- ========================================== -->
  <implementation-guide>
    <!-- New Island Component -->
    <component type="island" path="src/web/islands/GraphExplorer.tsx">
      <description>Search and exploration controls for the graph</description>
      <state>
        <item name="searchQuery" type="string">Current search input</item>
        <item name="searchResults" type="SearchResult[]">Autocomplete results</item>
        <item name="searchHistory" type="string[]">Last 10 searches (localStorage)</item>
        <item name="selectedNodes" type="Set&lt;string&gt;">Nodes selected for export</item>
        <item name="pathStart" type="string | null">Path finder start node</item>
        <item name="pathEnd" type="string | null">Path finder end node</item>
        <item name="neighborDepth" type="number">Current neighbor search depth (1-3)</item>
      </state>
      <props>
        <prop name="apiBase" type="string">Gateway API URL</prop>
        <prop name="onHighlightNodes" type="(nodeIds: string[]) => void"
        >Callback to highlight nodes in graph</prop>
        <prop name="onShowPath" type="(path: string[]) => void"
        >Callback to show path in graph</prop>
      </props>
      <features>
        <feature id="F1">Search input with debounced autocomplete</feature>
        <feature id="F2">Search history dropdown from localStorage</feature>
        <feature id="F3">Neighbor finder with depth selector (1-3 hops)</feature>
        <feature id="F4">Path finder with from/to tool selection</feature>
        <feature id="F5">Subgraph export (JSON/DOT)</feature>
        <feature id="F6">Keyboard shortcuts (/, Escape)</feature>
      </features>
    </component>

    <!-- GraphVisualization Extensions -->
    <component type="extension" path="src/web/islands/GraphVisualization.tsx">
      <modifications>
        <modification>
          <description>Add methods to highlight nodes and show paths</description>
          <code-snippet
          >
// Add to GraphVisualization.tsx
const highlightNodes = (nodeIds: string[]) => {
  if (!cyRef.current) return;

  // Clear previous highlights
  cyRef.current.nodes().removeClass('search-highlight');

  // Highlight matching nodes
  nodeIds.forEach(id => {
    const node = cyRef.current.$id(id);
    if (node.length) {
      node.addClass('search-highlight');
    }
  });

  // Fit view to highlighted nodes if any
  if (nodeIds.length > 0) {
    const highlighted = cyRef.current.nodes('.search-highlight');
    cyRef.current.fit(highlighted, 50);
  }
};

const showPath = (path: string[]) => {
  if (!cyRef.current || path.length &lt; 2) return;

  // Clear previous path
  cyRef.current.edges().removeClass('path-highlight');
  cyRef.current.nodes().removeClass('path-node');

  // Highlight path nodes and edges
  for (let i = 0; i &lt; path.length; i++) {
    cyRef.current.$id(path[i]).addClass('path-node');
    if (i &lt; path.length - 1) {
      const edge = cyRef.current.edges(`[source = "${path[i]}"][target = "${path[i+1]}"]`);
      edge.addClass('path-highlight');
    }
  }

  // Fit view to path
  const pathNodes = cyRef.current.nodes('.path-node');
  cyRef.current.fit(pathNodes, 50);
};
          </code-snippet>
        </modification>
        <modification>
          <description>Add CSS styles for highlights</description>
          <code-snippet
          >
// Add to Cytoscape style array
{
  selector: 'node.search-highlight',
  style: {
    'border-color': '#f59e0b',
    'border-width': 4,
    'z-index': 100,
  },
},
{
  selector: 'node.path-node',
  style: {
    'border-color': '#10b981',
    'border-width': 4,
    'z-index': 100,
  },
},
{
  selector: 'edge.path-highlight',
  style: {
    'line-color': '#10b981',
    'target-arrow-color': '#10b981',
    'width': 4,
    'opacity': 1,
    'z-index': 100,
  },
},
          </code-snippet>
        </modification>
      </modifications>
    </component>

    <!-- Backend API -->
    <api-endpoints>
      <endpoint path="/api/graph/search" method="GET">
        <query-param name="q" type="string" required="true">Search query (min 2 chars)</query-param>
        <query-param name="limit" type="number" required="false" default="10"
        >Max results</query-param>
        <response type="SearchResult[]">Array of matching tools</response>
        <implementation>
          <description>Prefix search on tool ID and label, case-insensitive</description>
          <code-snippet
          >
// In gateway-server.ts
if (url.pathname === "/api/graph/search" &amp;&amp; req.method === "GET") {
  const q = url.searchParams.get("q") || "";
  const limit = parseInt(url.searchParams.get("limit") || "10");

  if (q.length &lt; 2) {
    return new Response(JSON.stringify({ results: [] }), {
      headers: { "Content-Type": "application/json", ...corsHeaders },
    });
  }

  const results = this.graphEngine.searchNodes(q, limit);
  return new Response(JSON.stringify({ results }), {
    headers: { "Content-Type": "application/json", ...corsHeaders },
  });
}
          </code-snippet>
        </implementation>
      </endpoint>

      <endpoint path="/api/graph/neighbors" method="GET">
        <query-param name="tool_id" type="string" required="true">Center tool ID</query-param>
        <query-param name="depth" type="number" required="false" default="1"
        >Hops (1-3)</query-param>
        <response type="NeighborsResponse">Neighbor data</response>
        <implementation>
          <description>BFS traversal to find neighbors at depth</description>
        </implementation>
      </endpoint>

      <endpoint path="/api/graph/path" method="GET">
        <query-param name="from" type="string" required="true">Source tool ID</query-param>
        <query-param name="to" type="string" required="true">Target tool ID</query-param>
        <response type="PathResponse">Shortest path data</response>
        <implementation>
          <description>Dijkstra shortest path using graphology-shortest-path</description>
          <code-snippet
          >
// In graph-engine.ts
import { dijkstra } from "graphology-shortest-path";

getShortestPath(fromToolId: string, toToolId: string): string[] | null {
  if (!this.graph.hasNode(fromToolId) || !this.graph.hasNode(toToolId)) {
    return null;
  }

  try {
    const path = dijkstra.bidirectional(this.graph, fromToolId, toToolId);
    return path;
  } catch {
    return null; // No path exists
  }
}
          </code-snippet>
        </implementation>
      </endpoint>
    </api-endpoints>
  </implementation-guide>

  <!-- ========================================== -->
  <!-- CONSTRAINTS AND PATTERNS -->
  <!-- ========================================== -->
  <constraints>
    <constraint type="performance">
      <description>Search autocomplete must respond in &lt;100ms</description>
      <mitigation>Use in-memory prefix search, limit results to 10</mitigation>
    </constraint>
    <constraint type="performance">
      <description>Path finding must complete in &lt;500ms for graphs up to 500 nodes</description>
      <mitigation>Use Dijkstra with early termination</mitigation>
    </constraint>
    <constraint type="ux">
      <description>Autocomplete debounce 300ms to avoid excessive API calls</description>
    </constraint>
    <constraint type="security">
      <description>Validate tool IDs to prevent injection</description>
      <mitigation>Check tool ID exists in graph before operations</mitigation>
    </constraint>
    <constraint type="architecture">
      <description>Follow Fresh Islands pattern for interactive components</description>
    </constraint>
    <constraint type="architecture">
      <description
      >Maintain API base hard-coded in islands (Fresh props serialization limitation)</description>
    </constraint>
  </constraints>

  <!-- ========================================== -->
  <!-- PATTERNS FROM PREVIOUS STORIES -->
  <!-- ========================================== -->
  <patterns-to-reuse>
    <pattern from="6.2">
      <name>Cytoscape node/edge styling</name>
      <location>src/web/islands/GraphVisualization.tsx:68-127</location>
    </pattern>
    <pattern from="6.2">
      <name>SSE EventSource integration</name>
      <location>src/web/islands/GraphVisualization.tsx:171-224</location>
    </pattern>
    <pattern from="6.3">
      <name>Fresh Island with useState/useEffect</name>
      <location>src/web/islands/MetricsPanel.tsx</location>
    </pattern>
    <pattern from="6.3">
      <name>Export functionality (Blob/download)</name>
      <location>src/web/islands/MetricsPanel.tsx:221-260</location>
    </pattern>
    <pattern from="6.3">
      <name>CORS headers for API endpoints</name>
      <location>src/mcp/gateway-server.ts:1873-1877</location>
    </pattern>
  </patterns-to-reuse>

  <!-- ========================================== -->
  <!-- TEST REQUIREMENTS -->
  <!-- ========================================== -->
  <test-requirements>
    <test type="unit" file="tests/unit/graphrag/graph_engine_search_test.ts">
      <case>searchNodes returns matching tools by prefix</case>
      <case>searchNodes is case-insensitive</case>
      <case>searchNodes respects limit parameter</case>
      <case>searchNodes returns empty array for no matches</case>
    </test>
    <test type="unit" file="tests/unit/graphrag/graph_engine_neighbors_test.ts">
      <case>getNeighborsAtDepth returns direct neighbors at depth 1</case>
      <case>getNeighborsAtDepth returns 2-hop neighbors at depth 2</case>
      <case>getNeighborsAtDepth returns empty for isolated node</case>
      <case>getNeighborsAtDepth handles non-existent node</case>
    </test>
    <test type="unit" file="tests/unit/graphrag/graph_engine_path_test.ts">
      <case>getShortestPath returns correct path between connected nodes</case>
      <case>getShortestPath returns null for disconnected nodes</case>
      <case>getShortestPath returns single-element path for same node</case>
      <case>getShortestPath handles non-existent nodes</case>
    </test>
    <test type="integration" file="tests/integration/graph_explorer_api_test.ts">
      <case>/api/graph/search returns JSON with results array</case>
      <case>/api/graph/neighbors returns neighbors for valid tool</case>
      <case>/api/graph/path returns path between connected tools</case>
      <case>API endpoints return proper CORS headers</case>
    </test>
  </test-requirements>

  <!-- ========================================== -->
  <!-- DEPENDENCIES -->
  <!-- ========================================== -->
  <dependencies>
    <dependency type="runtime" already-installed="true">
      <name>graphology-shortest-path</name>
      <version>^2.0.2</version>
      <usage>dijkstra.bidirectional() for path finding</usage>
    </dependency>
    <dependency type="runtime" already-installed="true">
      <name>cytoscape</name>
      <version>3.30.4</version>
      <source>CDN (jsdelivr)</source>
      <usage>Graph visualization and interaction</usage>
    </dependency>
  </dependencies>

  <!-- ========================================== -->
  <!-- FILES TO CREATE -->
  <!-- ========================================== -->
  <files-to-create>
    <file path="src/web/islands/GraphExplorer.tsx">
      <description>Main search and exploration island component</description>
      <estimated-lines>300-400</estimated-lines>
    </file>
    <file path="tests/unit/graphrag/graph_engine_search_test.ts">
      <description>Unit tests for searchNodes method</description>
    </file>
    <file path="tests/unit/graphrag/graph_engine_neighbors_test.ts">
      <description>Unit tests for getNeighborsAtDepth method</description>
    </file>
    <file path="tests/unit/graphrag/graph_engine_path_test.ts">
      <description>Unit tests for getShortestPath method</description>
    </file>
    <file path="tests/integration/graph_explorer_api_test.ts">
      <description>Integration tests for search/neighbors/path API endpoints</description>
    </file>
  </files-to-create>

  <!-- ========================================== -->
  <!-- FILES TO MODIFY -->
  <!-- ========================================== -->
  <files-to-modify>
    <file path="src/graphrag/graph-engine.ts">
      <changes>
        <change>Add searchNodes() method</change>
        <change>Add getNeighborsAtDepth() method</change>
        <change>Add getShortestPath() method</change>
      </changes>
    </file>
    <file path="src/mcp/gateway-server.ts">
      <changes>
        <change>Add /api/graph/search endpoint</change>
        <change>Add /api/graph/neighbors endpoint</change>
        <change>Add /api/graph/path endpoint</change>
      </changes>
    </file>
    <file path="src/web/routes/dashboard.tsx">
      <changes>
        <change>Import and integrate GraphExplorer island</change>
        <change>Add CSS for search panel and highlights</change>
      </changes>
    </file>
    <file path="src/web/islands/GraphVisualization.tsx">
      <changes>
        <change>Add highlightNodes() function</change>
        <change>Add showPath() function</change>
        <change>Add CSS classes for search-highlight, path-node, path-highlight</change>
        <change>Expose highlight/path functions via props or ref</change>
      </changes>
    </file>
  </files-to-modify>

  <!-- ========================================== -->
  <!-- TASK BREAKDOWN -->
  <!-- ========================================== -->
  <tasks>
    <task id="T1" ac="AC1,AC6,AC7">
      <title>Create GraphExplorer island with search input</title>
      <subtasks>
        <subtask>1.1: Create GraphExplorer.tsx with search state</subtask>
        <subtask>1.2: Implement debounced autocomplete (300ms)</subtask>
        <subtask>1.3: Implement search history with localStorage</subtask>
        <subtask>1.4: Implement keyboard shortcuts (/, Escape)</subtask>
        <subtask>1.5: Add search results dropdown UI</subtask>
      </subtasks>
    </task>
    <task id="T2" ac="AC1,AC2">
      <title>Implement backend search API</title>
      <subtasks>
        <subtask>2.1: Add searchNodes() to GraphRAGEngine</subtask>
        <subtask>2.2: Add /api/graph/search endpoint</subtask>
        <subtask>2.3: Unit tests for searchNodes()</subtask>
      </subtasks>
    </task>
    <task id="T3" ac="AC2">
      <title>Implement node highlighting in GraphVisualization</title>
      <subtasks>
        <subtask>3.1: Add highlightNodes() function</subtask>
        <subtask>3.2: Add CSS styles for search-highlight class</subtask>
        <subtask>3.3: Connect GraphExplorer to GraphVisualization via callback</subtask>
      </subtasks>
    </task>
    <task id="T4" ac="AC3">
      <title>Implement Find Neighbors feature</title>
      <subtasks>
        <subtask>4.1: Add getNeighborsAtDepth() to GraphRAGEngine</subtask>
        <subtask>4.2: Add /api/graph/neighbors endpoint</subtask>
        <subtask>4.3: Add neighbor finder UI (depth selector 1-3)</subtask>
        <subtask>4.4: Unit tests for getNeighborsAtDepth()</subtask>
      </subtasks>
    </task>
    <task id="T5" ac="AC4">
      <title>Implement Path Finder feature</title>
      <subtasks>
        <subtask>5.1: Add getShortestPath() to GraphRAGEngine using Dijkstra</subtask>
        <subtask>5.2: Add /api/graph/path endpoint</subtask>
        <subtask>5.3: Add path finder UI (from/to tool selection)</subtask>
        <subtask>5.4: Add showPath() to GraphVisualization with path-highlight styles</subtask>
        <subtask>5.5: Unit tests for getShortestPath()</subtask>
      </subtasks>
    </task>
    <task id="T6" ac="AC5">
      <title>Implement Subgraph Export</title>
      <subtasks>
        <subtask>6.1: Add export format selector (JSON/DOT)</subtask>
        <subtask>6.2: Implement JSON export for selected nodes</subtask>
        <subtask>6.3: Implement DOT format export</subtask>
        <subtask>6.4: Reuse Blob/download pattern from MetricsPanel</subtask>
      </subtasks>
    </task>
    <task id="T7" ac="AC1">
      <title>Integrate GraphExplorer into dashboard</title>
      <subtasks>
        <subtask>7.1: Import GraphExplorer in dashboard.tsx</subtask>
        <subtask>7.2: Position search panel (top-left overlay or integrated header)</subtask>
        <subtask>7.3: Add CSS for explorer panel</subtask>
        <subtask>7.4: Wire up callbacks between GraphExplorer and GraphVisualization</subtask>
      </subtasks>
    </task>
    <task id="T8" ac="AC8">
      <title>Integration tests</title>
      <subtasks>
        <subtask>8.1: Test /api/graph/search endpoint</subtask>
        <subtask>8.2: Test /api/graph/neighbors endpoint</subtask>
        <subtask>8.3: Test /api/graph/path endpoint</subtask>
        <subtask>8.4: Verify CORS headers on all endpoints</subtask>
      </subtasks>
    </task>
  </tasks>

  <!-- ========================================== -->
  <!-- DOT FORMAT REFERENCE -->
  <!-- ========================================== -->
  <reference id="dot-format">
    <description>DOT graph format example for export</description>
    <example
    >
digraph Casys Intelligence {
  // Nodes
  "mcp__filesystem__read_file" [label="read_file", server="filesystem"];
  "mcp__json__parse" [label="parse", server="json"];

  // Edges
  "mcp__filesystem__read_file" -> "mcp__json__parse" [confidence=0.85];
}
    </example>
  </reference>

  <!-- ========================================== -->
  <!-- KEYBOARD SHORTCUTS SPECIFICATION -->
  <!-- ========================================== -->
  <keyboard-shortcuts>
    <shortcut key="/" action="Focus search input">
      <implementation>document.addEventListener('keydown') with focus()</implementation>
    </shortcut>
    <shortcut key="Escape" action="Clear search and unfocus">
      <implementation>Clear searchQuery state, blur input</implementation>
    </shortcut>
  </keyboard-shortcuts>
</story-context>
