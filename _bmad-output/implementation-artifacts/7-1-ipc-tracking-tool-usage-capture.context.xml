<story-context id="7-1-ipc-tracking-tool-usage-capture" v="1.0">
  <metadata>
    <epicId>7</epicId>
    <storyId>7.1</storyId>
    <title>IPC Tracking - Tool Usage Capture</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-12-05</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/7-1-ipc-tracking-tool-usage-capture.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>system learning from execution</asA>
    <iWant>to track which tools are ACTUALLY called during code execution</iWant>
    <soThat>GraphRAG learns from real usage patterns instead of just injected tools</soThat>
    <tasks>
      <task id="1" ac="1,2">
        <title>Implémenter le tracing dans context-builder.ts</title>
        <subtasks>
          <subtask id="1.1">Créer wrapToolCall() helper function</subtask>
          <subtask id="1.2">Modifier wrapMCPClient() pour wrapper chaque tool avec tracing</subtask>
          <subtask id="1.3">Générer trace_id via crypto.randomUUID()</subtask>
          <subtask id="1.4">Émettre tool_start event au début de l'appel</subtask>
          <subtask id="1.5">Émettre tool_end event avec success/failure et duration_ms</subtask>
        </subtasks>
      </task>
      <task id="2" ac="3,5">
        <title>Implémenter le parsing des traces dans gateway-server.ts</title>
        <subtasks>
          <subtask id="2.1">Créer interface TraceEvent et ParsedTraces</subtask>
          <subtask id="2.2">Implémenter parseTraces(stdout) function</subtask>
          <subtask id="2.3">Filtrer les lignes __TRACE__ du stdout</subtask>
          <subtask id="2.4">Parser chaque trace JSON et collecter toolsCalled</subtask>
          <subtask id="2.5">Retourner cleanOutput sans traces visibles</subtask>
        </subtasks>
      </task>
      <task id="3" ac="4">
        <title>Intégrer avec GraphRAG</title>
        <subtasks>
          <subtask id="3.1">Modifier handler execute_code pour appeler parseTraces()</subtask>
          <subtask id="3.2"
          >Appeler graphEngine.updateFromExecution(toolsCalled) si tools > 0</subtask>
          <subtask id="3.3">Vérifier que les edges sont créés entre tools co-utilisés</subtask>
        </subtasks>
      </task>
      <task id="4" ac="6">
        <title>Tests unitaires trace parsing</title>
        <subtasks>
          <subtask id="4.1">Créer tests/unit/sandbox/trace_parsing_test.ts</subtask>
          <subtask id="4.2">Test: extraction d'un tool call simple</subtask>
          <subtask id="4.3">Test: extraction de multiple tools</subtask>
          <subtask id="4.4">Test: exclusion des tools failed</subtask>
          <subtask id="4.5">Test: backward compatibility (pas de traces)</subtask>
        </subtasks>
      </task>
      <task id="5" ac="6">
        <title>Tests intégration GraphRAG update</title>
        <subtasks>
          <subtask id="5.1">Créer tests/integration/trace_graphrag_test.ts</subtask>
          <subtask id="5.2">Test: execute code avec 2 tools vers edges créés dans GraphRAG</subtask>
          <subtask id="5.3">Vérifier graphEngine.getEdgesBetween() retourne edge</subtask>
        </subtasks>
      </task>
      <task id="6" ac="7">
        <title>Performance validation</title>
        <subtasks>
          <subtask id="6.1">Mesurer overhead du tracing (cible moins de 5ms)</subtask>
          <subtask id="6.2">Benchmark: 100 tool calls avec tracing</subtask>
          <subtask id="6.3">Comparer latence avec/sans tracing</subtask>
        </subtasks>
      </task>
      <task id="7" ac="8">
        <title>Backward compatibility</title>
        <subtasks>
          <subtask id="7.1">Vérifier code sans traces fonctionne toujours</subtask>
          <subtask id="7.2">Vérifier output clean quand pas de traces</subtask>
          <subtask id="7.3">Test: ancien code sandbox continue de fonctionner</subtask>
        </subtasks>
      </task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1"
    >Wrappers __TRACE__ ajoutés dans context-builder.ts:wrapMCPClient() (~30 LOC)</criterion>
    <criterion id="AC2"
    >Event types émis: tool_start (avec trace_id, ts) et tool_end (avec success, duration_ms)</criterion>
    <criterion id="AC3"
    >Parser parseTraces(stdout) dans gateway-server.ts extrait les traces</criterion>
    <criterion id="AC4"
    >Appel graphEngine.updateFromExecution() avec tools réellement appelés</criterion>
    <criterion id="AC5">Traces filtrées du stdout retourné (user ne voit pas __TRACE__)</criterion>
    <criterion id="AC6"
    >Tests: exécuter code avec 2 tools puis vérifier edges créés dans GraphRAG</criterion>
    <criterion id="AC7">Performance: overhead moins de 5ms par tool call</criterion>
    <criterion id="AC8">Backward compatible: code sans traces fonctionne toujours</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/adrs/ADR-027-execute-code-graph-learning.md</path>
        <title>ADR-027: Execute Code Graph Learning Integration</title>
        <section>Decision - Option B (Accurate Tracking)</section>
        <snippet
        >IPC via __TRACE__ prefix on stdout. Code execution tracking worth implementation complexity. Emit tool_start/tool_end events with trace_id, timestamp, success, duration_ms.</snippet>
      </doc>
      <doc>
        <path>docs/adrs/ADR-028-emergent-capabilities-system.md</path>
        <title>ADR-028: Emergent Capabilities System</title>
        <section>IPC: Communication Sandbox to Parent</section>
        <snippet
        >stdout avec prefix __TRACE__ avec parsing cote Gateway. Event types: tool_start, tool_end, progress, log, capability_hint. Architecture 3 couches: Orchestration / Capability Engine / Execution.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture - Casys Intelligence</title>
        <section>Pattern 5: Agent Code Execution</section>
        <snippet
        >DenoSandboxExecutor with subprocess isolation. ContextBuilder with vector search integration. execute_code MCP tool in gateway-server.ts. Safe-to-fail pattern with sandbox isolation.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Epic 7: Emergent Capabilities</section>
        <snippet
        >Story 7.1: IPC Tracking - capture actual tool usage via __TRACE__ events in sandbox stdout. Foundation for learning system.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 7 Overview</section>
        <snippet
        >Layer 3 (Execution) implements wrappers traces in sandbox. Traces parsed by Layer 2 (Capability Engine) for GraphRAG updates.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/sandbox/context-builder.ts</path>
        <kind>module</kind>
        <symbol>wrapMCPClient</symbol>
        <lines>355-408</lines>
        <reason
        >Point d'injection pour le tracing. Fonction qui wrappe les MCP tools - ajouter emission __TRACE__ ici</reason>
      </artifact>
      <artifact>
        <path>src/mcp/gateway-server.ts</path>
        <kind>handler</kind>
        <symbol>handleExecuteCode</symbol>
        <lines>1019-1148</lines>
        <reason
        >Handler execute_code ou ajouter parseTraces() et appel graphEngine.updateFromExecution()</reason>
      </artifact>
      <artifact>
        <path>src/graphrag/graph-engine.ts</path>
        <kind>method</kind>
        <symbol>updateFromExecution</symbol>
        <lines>325-390</lines>
        <reason
        >Methode existante pour mettre a jour GraphRAG avec execution. A appeler avec tools reellement appeles</reason>
      </artifact>
      <artifact>
        <path>src/graphrag/types.ts</path>
        <kind>interface</kind>
        <symbol>WorkflowExecution</symbol>
        <lines>69-77</lines>
        <reason
        >Interface pour les donnees d'execution. dag_structure.tasks contient les tools</reason>
      </artifact>
    </code>
    <dependencies>
      <ecosystem name="deno">
        <package name="deno" version="2.5/2.2 LTS" note="Runtime - crypto.randomUUID() natif" />
        <package name="@std/log" version="0.224.14" note="Logging structure" />
      </ecosystem>
      <ecosystem name="npm">
        <package name="graphology" version="0.25.4" note="Graph algorithms pour GraphRAG" />
        <package name="@electric-sql/pglite" version="0.3.11" note="PGlite pour persistance" />
      </ecosystem>
      <builtins>
        <builtin name="crypto.randomUUID()" note="Generation trace_id - natif Deno" />
        <builtin name="Date.now()" note="Timestamps pour tool_start/tool_end" />
        <builtin name="console.log()" note="Emission traces via stdout" />
        <builtin name="JSON.stringify()" note="Serialisation traces" />
        <builtin name="String.startsWith()" note="Detection prefix __TRACE__" />
        <builtin name="JSON.parse()" note="Parsing traces JSON" />
      </builtins>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="performance">Overhead tracing moins de 5ms par tool call (AC7)</constraint>
    <constraint type="compatibility"
    >Backward compatible - code sans traces doit fonctionner (AC8)</constraint>
    <constraint type="security"
    >Traces filtrees du stdout - user ne voit pas __TRACE__ (AC5)</constraint>
    <constraint type="architecture"
    >Layer 3 (Sandbox) emet traces, Layer 2 (Gateway) parse et filtre</constraint>
    <constraint type="pattern"
    >Utiliser prefix __TRACE__ sur stdout pour IPC sandbox vers parent</constraint>
    <constraint type="format"
    >JSON traces: tool_start (tool, trace_id, ts) et tool_end (trace_id, success, duration_ms)</constraint>
  </constraints>
  <interfaces>
    <interface>
      <name>TraceEvent</name>
      <kind>TypeScript interface</kind>
      <signature
      >type TraceEvent = { type: "tool_start"; tool: string; trace_id: string; ts: number } | { type: "tool_end"; trace_id: string; success: boolean; duration_ms: number; error?: string }</signature>
      <path>src/mcp/gateway-server.ts (nouveau)</path>
    </interface>
    <interface>
      <name>ParsedTraces</name>
      <kind>TypeScript interface</kind>
      <signature
      >interface ParsedTraces { cleanOutput: string; toolsCalled: string[]; traces: TraceEvent[] }</signature>
      <path>src/mcp/gateway-server.ts (nouveau)</path>
    </interface>
    <interface>
      <name>WorkflowExecution</name>
      <kind>TypeScript interface (existant)</kind>
      <signature
      >interface WorkflowExecution { execution_id: string; executed_at: Date; intent_text: string; dag_structure: DAGStructure; success: boolean; execution_time_ms: number }</signature>
      <path>src/graphrag/types.ts:69-77</path>
    </interface>
    <interface>
      <name>graphEngine.updateFromExecution</name>
      <kind>Method (existant)</kind>
      <signature
      >async updateFromExecution(execution: WorkflowExecution): Promise&lt;void&gt;</signature>
      <path>src/graphrag/graph-engine.ts:325</path>
    </interface>
  </interfaces>
  <tests>
    <standards
    >
      Deno.test() pour tous les tests. Assertions via @std/assert (assertEquals, assertExists, assertStringIncludes).
      Pattern Mock: Classes MockMCPClient implementant Partial&lt;MCPClient&gt;. Tests unitaires isoles, tests integration avec vraies deps.
      Performance: Benchmarks via Deno.bench(). Coverage cible &gt;80%. Tasks: deno task test:unit, deno task test:integration.
    </standards>
    <locations>
      <location
      >tests/unit/sandbox/ - Tests unitaires sandbox (context_builder_test.ts existe)</location>
      <location>tests/unit/mcp/ - Tests unitaires gateway</location>
      <location
      >tests/integration/ - Tests integration (graphrag_feedback_e2e_test.ts existe)</location>
      <location
      >tests/benchmarks/ - Tests performance (sandbox_performance_test.ts existe)</location>
    </locations>
    <ideas>
      <idea ac="AC1,AC2">Test: wrapToolCall() emet tool_start et tool_end avec format correct</idea>
      <idea ac="AC3">Test: parseTraces() extrait correctement les traces du stdout</idea>
      <idea ac="AC3">Test: parseTraces() gere les lignes malformees sans crash</idea>
      <idea ac="AC4">Test: toolsCalled passe a graphEngine.updateFromExecution()</idea>
      <idea ac="AC5">Test: cleanOutput ne contient pas de lignes __TRACE__</idea>
      <idea ac="AC6">Test integration: execute code avec 2 tools puis verifier edges GraphRAG</idea>
      <idea ac="AC7">Benchmark: mesurer overhead tracing (cible &lt;5ms)</idea>
      <idea ac="AC8">Test: code sans MCP tools retourne output propre (backward compat)</idea>
      <idea ac="AC8">Test: ancien code sandbox sans tracing fonctionne toujours</idea>
    </ideas>
  </tests>
</story-context>
