<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2.1</storyId>
    <title>GraphRAG Engine with Graphology</title>
    <status>drafted</status>
    <generatedAt>2025-11-05</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-2.1.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>Casys Intelligence to use Graphology for true graph algorithms (PageRank, community detection, path finding) with speculative execution</iWant>
    <soThat>the system can autonomously execute workflows with high confidence, dramatically reducing latency and context usage</soThat>
    <tasks>
      <task id="1">Integrate Graphology library and metrics packages</task>
      <task id="2">Implement GraphRAGEngine class with graph sync from PGlite</task>
      <task id="3">Implement PageRank computation for tool importance ranking</task>
      <task id="4">Implement community detection (Louvain) for tool clustering</task>
      <task id="5">Implement shortest path finding for dependency inference</task>
      <task id="6">Implement DAG builder using graph paths and topology</task>
      <task id="7">Implement speculative execution mode with safety checks</task>
      <task id="8">Implement adaptive threshold learning from user feedback</task>
      <task id="9">Implement dependency path extraction for explainability</task>
      <task id="10">Write comprehensive unit tests for all graph operations</task>
      <task id="11">Write tests for speculative execution modes</task>
      <task id="12">Benchmark performance targets (<300ms total)</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">Graphology library integrated (npm:graphology + metrics packages)</criterion>
    <criterion id="AC2">Graph sync from PGlite to Graphology in-memory graph</criterion>
    <criterion id="AC3">PageRank computation for tool importance ranking</criterion>
    <criterion id="AC4">Community detection (Louvain) for finding tool clusters</criterion>
    <criterion id="AC5">Shortest path finding for dependency inference</criterion>
    <criterion id="AC6">DAG builder using graph paths and topology</criterion>
    <criterion id="AC7">Performance: Graph sync &lt;50ms, PageRank &lt;100ms</criterion>
    <criterion id="AC8">Unit tests for graph operations</criterion>
    <criterion id="AC9">Speculative execution mode implementation (confidence-based)</criterion>
    <criterion id="AC10">Safety checks (dangerous operations, cost/time limits)</criterion>
    <criterion id="AC11">Graceful fallback to suggestion mode on speculation failure</criterion>
    <criterion id="AC12">Three execution modes: explicit_required, suggestion, speculative_execution</criterion>
    <criterion id="AC13">User feedback tracking (accept/reject/modify patterns)</criterion>
    <criterion id="AC14">Adaptive threshold learning based on user feedback</criterion>
    <criterion id="AC15">Metrics tracking (success rate, waste rate, speedup, acceptance rate)</criterion>
    <criterion id="AC16">Dependency paths extraction for DAG suggestions</criterion>
    <criterion id="AC17">Path explanation generation (direct vs transitive dependencies)</criterion>
    <criterion id="AC18">Subgraph export for visualization (JSON format)</criterion>
    <criterion id="AC19">Confidence scoring per dependency path</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>DAG Execution &amp; Orchestration</section>
        <snippet>FR005: Le système doit analyser les dépendances input/output entre tools pour construire un graphe de dépendances (DAG). FR006: Le système doit identifier automatiquement les tools exécutables en parallèle vs séquentiellement. FR007: Le système doit exécuter simultanément les branches indépendantes du DAG.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Non-Functional Requirements</section>
        <snippet>NFR001: Performance - Le système doit exécuter un workflow typique de 5 tools avec une latence P95 &lt;3 secondes (amélioration 5x vs exécution séquentielle baseline)</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture</title>
        <section>Technology Stack - Graph Algorithms</section>
        <snippet>Graphology: latest - True PageRank, Louvain, bidirectional search - "NetworkX of JavaScript". Epic 2: DAG Execution. Custom DAG Execution (zero deps): Topological sort + Promise.all, no external dependency.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Decision Architecture</title>
        <section>Project Structure</section>
        <snippet>src/dag/ - DAG execution (Epic 2): builder.ts (Story 2.1 - Dependency graph), executor.ts (Story 2.2 - Parallel execution), types.ts (DAG node/edge types)</snippet>
      </doc>
      <doc>
        <path>docs/graphrag-technical-implementation.md</path>
        <title>GraphRAG Technical Implementation Guide</title>
        <section>Complete Implementation Guide</section>
        <snippet>Comprehensive guide for implementing GraphRAG Engine with Graphology including: Database schema (tool_dependency table), GraphRAGEngine class implementation, DAGSuggester integration, Speculative execution modes, Adaptive threshold learning, Performance targets (&lt;300ms total), Testing strategy with Deno.test</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 2.1: Dependency Graph Construction (DAG Builder)</section>
        <snippet>Create DAG builder module, parse tool input/output schemas, detect dependencies, implement topological sort, detect cycles. Acceptance Criteria include: DAG representation with nodes and edges, dependency detection logic, API: buildDAG(tools: Tool[]) → DAG graph object</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/db/client.ts</path>
        <kind>database-client</kind>
        <symbol>PGliteClient</symbol>
        <lines>1-179</lines>
        <reason>Database client wrapper for PGlite - will be used for graph sync and persistence. Provides query(), exec(), transaction() methods needed for loading tool dependencies and persisting graph updates.</reason>
      </artifact>
      <artifact>
        <path>src/vector/search.ts</path>
        <kind>service</kind>
        <symbol>VectorSearch</symbol>
        <lines>33-137</lines>
        <reason>Vector search service that will be integrated with DAGSuggester. Provides searchTools() method that returns top-k relevant tools based on semantic similarity - these candidates will be used as input to graph-based DAG builder.</reason>
      </artifact>
      <artifact>
        <path>src/mcp/types.ts</path>
        <kind>types</kind>
        <symbol>MCPTool</symbol>
        <lines>22-27</lines>
        <reason>MCP Tool schema interface with inputSchema and outputSchema fields. These schemas are critical for dependency detection - tool B depends on tool A if output_A matches input_B.</reason>
      </artifact>
      <artifact>
        <path>src/mcp/types.ts</path>
        <kind>types</kind>
        <symbol>MCPServer</symbol>
        <lines>10-17</lines>
        <reason>MCP Server configuration interface. GraphRAG will track which server each tool belongs to for community detection and tool clustering.</reason>
      </artifact>
    </code>
    <dependencies>
      <ecosystem name="deno">
        <package name="@electric-sql/pglite" version="0.3.11">Embedded PostgreSQL WASM database - used for persisting tool dependencies and workflow patterns</package>
        <package name="@electric-sql/pglite/vector" version="0.3.11">pgvector extension for PGlite - provides vector search capabilities</package>
        <package name="@xenova/transformers" version="2.17.2">Hugging Face Transformers.js - provides BGE-Large-EN-v1.5 embeddings model</package>
        <package name="@std/assert" version="1.0.11">Deno standard library assertions for testing</package>
        <package name="@std/log" version="0.224.11">Deno standard library structured logging</package>
        <package name="@std/yaml" version="1.0.6">YAML parsing for configuration files</package>
        <package name="@cliffy/command" version="1.0.0-rc.7">Type-safe CLI framework for Deno</package>
      </ecosystem>
      <ecosystem name="npm-new">
        <package name="graphology" version="^0.25.4">Graph data structure library - "NetworkX of JavaScript" (~30KB gzipped)</package>
        <package name="graphology-metrics" version="^2.2.0">Graph metrics including PageRank centrality (~20KB gzipped)</package>
        <package name="graphology-shortest-path" version="^2.0.2">Bidirectional shortest path algorithms (~10KB gzipped)</package>
        <package name="graphology-communities-louvain" version="^2.0.1">Louvain community detection algorithm (~20KB gzipped)</package>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>Must maintain existing PGliteClient interface - do not break existing vector search functionality</constraint>
    <constraint>Graph sync from PGlite must complete in &lt;50ms P95 for typical workloads (100-200 tools, 50-100 dependencies)</constraint>
    <constraint>PageRank computation must complete in &lt;100ms to keep total initialization under 300ms</constraint>
    <constraint>Topological sort must detect cycles and report them as errors (invalid DAG)</constraint>
    <constraint>Zero external dependencies for DAG executor - use only Graphology for graph algorithms, custom implementation for DAG traversal</constraint>
    <constraint>TypeScript strict mode enabled - all code must have proper type definitions (noImplicitAny, noUnusedLocals, noUnusedParameters)</constraint>
    <constraint>Speculative execution must have safety checks - never execute dangerous operations (delete, remove, destroy, deploy, publish, payment, charge) without explicit confirmation</constraint>
    <constraint>Graceful degradation required - if speculative execution fails, must fall back to suggestion mode without crashing</constraint>
    <constraint>Adaptive thresholds must persist to database - learning should survive restarts</constraint>
    <constraint>All graph operations must be deterministic for testing - same input produces same output</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>GraphRAGEngine</name>
      <kind>class</kind>
      <signature>
class GraphRAGEngine {
  constructor(db: PGliteClient);
  async syncFromDatabase(): Promise&lt;void&gt;;
  getPageRank(toolId: string): number;
  getCommunity(toolId: string): string | undefined;
  findCommunityMembers(toolId: string): string[];
  findShortestPath(fromToolId: string, toToolId: string): string[] | null;
  buildDAG(candidateTools: string[]): DAGStructure;
  async updateFromExecution(execution: WorkflowExecution): Promise&lt;void&gt;;
  getStats(): GraphStats;
}
      </signature>
      <path>src/graphrag/graph-engine.ts</path>
    </interface>
    <interface>
      <name>DAGSuggester</name>
      <kind>class</kind>
      <signature>
class DAGSuggester {
  constructor(graphEngine: GraphRAGEngine, vectorSearch: VectorSearch);
  async suggestDAG(intent: WorkflowIntent): Promise&lt;SuggestedDAG | null&gt;;
}
      </signature>
      <path>src/graphrag/dag-suggester.ts</path>
    </interface>
    <interface>
      <name>GatewayHandler</name>
      <kind>class</kind>
      <signature>
class GatewayHandler {
  private thresholds = { speculative: 0.85, suggestion: 0.70, explicit: 0.70 };
  async initialize(): Promise&lt;void&gt;;
  async handleWorkflowRequest(request: { intent?: WorkflowIntent; workflow?: DAGStructure }): Promise&lt;ExecutionMode&gt;;
  private async executeSpeculatively(suggestion: SuggestedDAG, intent: WorkflowIntent): Promise&lt;ExecutionMode&gt;;
  private isDangerous(dag: DAGStructure): boolean;
}
      </signature>
      <path>src/mcp/gateway-handler.ts</path>
    </interface>
    <interface>
      <name>DAGStructure</name>
      <kind>type</kind>
      <signature>
interface DAGStructure {
  tasks: Task[];
}

interface Task {
  id: string;
  tool: string;
  arguments: Record&lt;string, unknown&gt;;
  depends_on: string[];
}
      </signature>
      <path>src/dag/types.ts</path>
    </interface>
    <interface>
      <name>ExecutionMode</name>
      <kind>type</kind>
      <signature>
interface ExecutionMode {
  mode: "explicit_required" | "suggestion" | "speculative_execution";
  confidence: number;
  dagStructure?: DAGStructure;
  results?: ExecutionResult[];
  explanation?: string;
  warning?: string;
  error?: string;
}
      </signature>
      <path>src/graphrag/types.ts</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Casys Intelligence uses Deno's native testing framework (Deno.test) with the following standards:
      - Test files located in tests/unit/, tests/integration/, tests/benchmarks/
      - Test files named with _test.ts suffix (e.g., graph_engine_test.ts)
      - Use @std/assert for assertions (assertEquals, assertExists, assert)
      - In-memory database for unit tests: new PGliteClient("memory://")
      - Fixtures for test data in tests/fixtures/
      - Performance benchmarks using Deno.bench with targets documented in acceptance criteria
      - Mock MCP servers in tests/mocks/ for integration testing
      - Code coverage target: &gt;80% (unit + integration)
      - Test structure: setup test environment, execute test, assert results, cleanup
    </standards>
    <locations>
      - tests/unit/graphrag/ (new directory for GraphRAG tests)
      - tests/unit/dag/ (new directory for DAG builder tests)
      - tests/integration/ (for gateway handler integration tests)
      - tests/benchmarks/ (for performance regression tests)
    </locations>
    <ideas>
      <test criterion="AC1">Test Graphology dependencies import and initialization</test>
      <test criterion="AC2">Test graph sync from PGlite loads nodes (tools) and edges (dependencies) correctly</test>
      <test criterion="AC2">Test graph sync completes within 50ms for 200 tools and 100 dependencies</test>
      <test criterion="AC3">Test PageRank computation returns scores between 0 and 1 for all nodes</test>
      <test criterion="AC3">Test PageRank ranks frequently used tools higher than rarely used tools</test>
      <test criterion="AC4">Test Louvain community detection groups related tools together</test>
      <test criterion="AC4">Test findCommunityMembers returns tools in same cluster</test>
      <test criterion="AC5">Test findShortestPath returns correct path between connected tools</test>
      <test criterion="AC5">Test findShortestPath returns null for disconnected tools</test>
      <test criterion="AC6">Test buildDAG creates correct dependencies based on graph topology</test>
      <test criterion="AC6">Test buildDAG handles tools with no dependencies (parallel execution)</test>
      <test criterion="AC6">Test buildDAG detects circular dependencies and throws error</test>
      <test criterion="AC7">Benchmark graph sync performance &lt;50ms P95</test>
      <test criterion="AC7">Benchmark PageRank computation &lt;100ms P95</test>
      <test criterion="AC9">Test speculative execution mode executes DAG when confidence &gt;=0.85</test>
      <test criterion="AC9">Test suggestion mode returns DAG without executing when 0.70&lt;=confidence&lt;0.85</test>
      <test criterion="AC9">Test explicit_required mode when confidence &lt;0.70</test>
      <test criterion="AC10">Test safety check prevents speculation on dangerous operations (delete, deploy, payment)</test>
      <test criterion="AC11">Test graceful fallback to suggestion mode when speculative execution fails</test>
      <test criterion="AC13,AC14">Test adaptive threshold learning lowers threshold after high success rate</test>
      <test criterion="AC13,AC14">Test adaptive threshold learning raises threshold after low success rate</test>
      <test criterion="AC15">Test metrics tracking records success rate, waste rate, speedup</test>
      <test criterion="AC16">Test dependency path extraction for transitive dependencies</test>
      <test criterion="AC17">Test path explanation distinguishes direct vs transitive dependencies</test>
      <test criterion="AC18">Test subgraph export to JSON for visualization</test>
    </ideas>
  </tests>
</story-context>
