<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.2</storyId>
    <title>MCP Tools Injection into Code Context</title>
    <status>drafted</status>
    <generatedAt>2025-11-13</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-3.2.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>agent</asA>
    <iWant>access to MCP tools within my code execution environment</iWant>
    <soThat>I can call tools directly from my TypeScript code instead of via JSON-RPC</soThat>
    <tasks>
      <phase name="Phase 1: Context Builder Foundation (2-3h)">
        <task
          id="task-1"
          ac="1"
        >Create context builder module
          - Créer `src/sandbox/context-builder.ts`
          - Créer interface `ToolContext` avec method signatures
          - Créer classe `ContextBuilder` pour orchestration
          - Exporter module dans `mod.ts`
        </task>
        <task
          id="task-2"
          ac="2,3"
        >MCP client wrapper generation
          - Créer fonction `wrapMCPClient(client: MCPClient): ToolFunctions`
          - Générer wrappers TypeScript pour chaque tool du client
          - Format: `const github = { listCommits: async (args) => client.callTool("list_commits", args) }`
          - Gérer conversion arguments (camelCase ↔ snake_case si nécessaire)
          - Retourner objet avec méthodes typées
        </task>
      </phase>
      <phase name="Phase 2: Vector Search Integration (2h)">
        <task
          id="task-3"
          ac="4"
        >Vector search for relevant tools
          - Intégrer `VectorSearch` dans `ContextBuilder`
          - Utiliser intent/query pour identifier top-k tools pertinents (default k=5)
          - Ne charger que les MCP clients pour tools identifiés
          - Éviter injection de tous les tools (économie mémoire/contexte)
          - Logger tools injectés pour debugging
        </task>
        <task
          id="task-4"
          ac="5"
        >Type definitions generation
          - Générer TypeScript type definitions depuis MCP tool schemas
          - Parser `inputSchema` (JSON Schema) → TypeScript interface
          - Créer `.d.ts` virtuel pour autocomplete dans sandbox
          - Supporter types: string, number, boolean, object, array
          - Handle optionals et required fields
        </task>
      </phase>
      <phase name="Phase 3: Gateway Routing & Error Handling (2h)">
        <task
          id="task-5"
          ac="6"
        >Route tool calls through gateway
          - Wrapper calls doivent utiliser existing MCP gateway infrastructure
          - Réutiliser `MCPClient.callTool()` méthode (pas de duplication)
          - Respecter rate limiting et health checks existants
          - Logger tous les tool calls pour telemetry
        </task>
        <task
          id="task-6"
          ac="7"
        >Error propagation
          - Capturer MCP errors (server errors, tool errors, timeouts)
          - Convertir en JavaScript exceptions avec stack trace
          - Préserver error details (code, message, data)
          - Format: `throw new MCPToolError(toolName, originalError)`
          - Permettre try/catch dans code agent
        </task>
      </phase>
      <phase name="Phase 4: Testing & Integration (1-2h)">
        <task
          id="task-7"
          ac="8"
        >Integration tests
          - Test: Inject GitHub client → call `github.listCommits()` → receive results
          - Test: Multiple tools injection (github + filesystem)
          - Test: Vector search filters tools correctly (only relevant injected)
          - Test: Error handling (tool fails → exception thrown in sandbox)
          - Test: Type safety (TypeScript compilation validates signatures)
        </task>
        <task
          id="task-8"
          ac="9"
        >Security validation
          - Audit: No `eval()` usage in context builder
          - Audit: No `Function()` constructor
          - Audit: No dynamic code generation (template strings ok, mais pas eval)
          - Test: Malicious tool name → rejection (e.g., `__proto__`)
          - Test: Tool wrapper cannot escape sandbox
        </task>
      </phase>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="ac-1">Tool injection system créé (`src/sandbox/context-builder.ts`)</criterion>
    <criterion id="ac-2"
    >MCP clients wrapped as TypeScript functions accessible in sandbox</criterion>
    <criterion id="ac-3"
    >Code context includes: `const github = { listCommits: async (...) => ... }`</criterion>
    <criterion id="ac-4"
    >Vector search used to identify relevant tools (only inject top-k, not all)</criterion>
    <criterion id="ac-5"
    >Type definitions generated for injected tools (TypeScript autocomplete support)</criterion>
    <criterion id="ac-6">Tool calls from sandbox routed through existing MCP gateway</criterion>
    <criterion id="ac-7">Error propagation: MCP errors surfaced as JavaScript exceptions</criterion>
    <criterion id="ac-8"
    >Integration test: Agent code calls `github.listCommits()` successfully</criterion>
    <criterion id="ac-9">Security: No eval() or dynamic code generation in injection</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc
        path="docs/spikes/architecture-spike-mcp-tools-injection.md"
        title="Architecture Spike: MCP Tools Injection dans Sandbox Deno"
        section="7. Recommandation & 8. Security Considerations"
      >
        Comprehensive architecture spike defining 3 design options with trade-offs, recommending Option 2 (API Bridge via Message Passing), security threat model, and implementation phases. Essential reference for security patterns and design decisions.
      </doc>
      <doc
        path="docs/mcp-integration-model.md"
        title="Casys Intelligence MCP Integration Model"
        section="1. Architecture d'Intégration & 3. Runtime"
      >
        Documents the gateway proxy architecture where Casys Intelligence wraps all MCP servers, configuration flow, tool naming conventions (serverId:toolName), and integration with Claude Code. Critical for understanding how MCP clients are managed.
      </doc>
      <doc
        path="docs/stories/story-3.1.md"
        title="Story 3.1: Deno Sandbox Executor Foundation"
        section="Architecture Integration & Dev Notes"
      >
        Completed story documenting CodeSandbox class, permissions model, subprocess isolation, timeout/memory enforcement. Provides the foundation that Story 3.2 will extend with tool injection capabilities.
      </doc>
      <doc
        path="docs/PRD.md"
        title="Product Requirements Document"
        section="Epic 3 - Agent Code Execution"
      >
        High-level product requirements for agent code execution within sandbox, including context optimization via vector search and MCP tool accessibility.
      </doc>
      <doc
        path="docs/architecture.md"
        title="Architecture Documentation"
        section="Sandbox & MCP Integration"
      >
        System architecture overview showing how sandbox, vector search, and MCP components integrate together.
      </doc>
    </docs>
    <code>
      <artifact
        path="src/sandbox/executor.ts"
        kind="module"
        symbol="DenoSandboxExecutor"
        lines="60-200"
      >
        Production sandbox executor class providing secure Deno subprocess execution with permission whitelisting, timeout/memory enforcement, and error capturing. Story 3.2 will extend this to accept tool context parameter.
      </artifact>
      <artifact
        path="src/sandbox/types.ts"
        kind="module"
        symbol="SandboxConfig, ExecutionResult"
        lines="1-100"
      >
        TypeScript type definitions for sandbox configuration and execution results. Story 3.2 should add ToolContext interface here.
      </artifact>
      <artifact
        path="src/vector/search.ts"
        kind="module"
        symbol="VectorSearch.searchTools"
        lines="54-100"
      >
        Vector search implementation using BGE-Large-EN-v1.5 embeddings for semantic tool discovery. Returns top-k tools with similarity scores. Core component for tool filtering in Story 3.2.
      </artifact>
      <artifact
        path="src/mcp/client.ts"
        kind="module"
        symbol="MCPClient.callTool"
        lines="1-150"
      >
        MCP client implementation for stdio-based MCP server communication. Provides callTool() method that Story 3.2 tool wrappers will route through.
      </artifact>
      <artifact
        path="src/mcp/gateway-handler.ts"
        kind="module"
        symbol="GatewayHandler"
        lines="1-100"
      >
        Gateway handler orchestrating vector search and MCP clients. Integration point for future tool context builder.
      </artifact>
      <artifact
        path="src/mcp/gateway-server.ts"
        kind="module"
        symbol="Casys IntelligenceGatewayServer"
        lines="1-100"
      >
        MCP gateway server managing tool listing and execution. Will accept requests from sandbox bridge (Story 3.2).
      </artifact>
      <artifact
        path="src/db/client.ts"
        kind="module"
        symbol="PGliteClient"
        lines="1-80"
      >
        Database client managing tool schema storage and embedding queries. Used by VectorSearch for tool discovery.
      </artifact>
      <artifact
        path="mod.ts"
        kind="module"
        symbol="exports"
        lines="1-50"
      >
        Main module exports. Story 3.2 should add ContextBuilder to exports.
      </artifact>
    </code>
    <dependencies>
      <ecosystem
        name="deno"
        framework="Deno 2.5+"
        version="stable"
      >
        Runtime environment with subprocess API, Workers API, and TypeScript native support
      </ecosystem>
      <package
        name="@modelcontextprotocol/sdk"
        version="^1.0.4"
      >
        Official MCP SDK for protocol types, transports, and utilities
      </package>
      <package
        name="@electric-sql/pglite"
        version="0.3.11"
      >
        Embedded PostgreSQL with pgvector support for semantic search
      </package>
      <package
        name="@xenova/transformers"
        version="2.17.2"
      >
        ONNX Runtime for BGE-Large-EN-v1.5 embeddings (used by VectorSearch)
      </package>
      <package
        name="@std/assert"
        version="1.0.11"
      >
        Standard library assertions for testing
      </package>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>No eval() or Function() constructor - respect sandbox security model</constraint>
    <constraint
    >Whitelist tool name patterns: [a-z0-9_-]+:[a-z0-9_-]+ (reject __proto__, constructor)</constraint>
    <constraint>Use message passing for tool invocation, not function serialization</constraint>
    <constraint
    >Dependency on Story 3.1 (CodeSandbox) - must use sandbox initialization context</constraint>
    <constraint>Reuse VectorSearch from src/vector/search.ts for tool discovery</constraint>
    <constraint>Reuse existing MCPClient instances and MCP gateway infrastructure</constraint>
    <constraint>Respect rate limiting and health checks from Story 2.5 & 2.6</constraint>
    <constraint
    >Only inject top-k relevant tools (default k=5) to minimize context overhead</constraint>
  </constraints>

  <interfaces>
    <interface name="ToolContext" kind="TypeScript Interface">
      <signature
      >interface ToolContext { [key: string]: { [methodName: string]: Function } }</signature>
      <path>src/sandbox/context-builder.ts</path>
      <description
      >Type for injected tool context - maps tool names to wrapped functions</description>
    </interface>
    <interface name="ContextBuilder" kind="TypeScript Class">
      <signature
      >class ContextBuilder { buildContext(intent: string, topK?: number): Promise&lt;ToolContext&gt; }</signature>
      <path>src/sandbox/context-builder.ts</path>
      <description>Main orchestration class for tool injection and context building</description>
    </interface>
    <interface name="wrapMCPClient" kind="TypeScript Function">
      <signature>wrapMCPClient(client: MCPClient): { [key: string]: AsyncFunction }</signature>
      <path>src/sandbox/context-builder.ts</path>
      <description
      >Converts MCP client tools into TypeScript async functions for sandbox injection</description>
    </interface>
    <interface name="MCPClient.callTool" kind="MCP Gateway Method">
      <signature
      >callTool(name: string, args: Record&lt;string, unknown&gt;): Promise&lt;ToolResult&gt;</signature>
      <path>src/mcp/client.ts</path>
      <description
      >Existing MCP client method - tool calls routed through this with health checks and rate limiting</description>
    </interface>
  </interfaces>

  <tests>
    <standards
    >Test organization in tests/unit/sandbox/: context_builder_test.ts (unit tests), tool_wrapper_test.ts (wrapper generation), type_generation_test.ts (type generation), integration_test.ts (full flow). Reuse MockMCPServer from Story 2.7 for mocking. Mock strategy: minimal GitHub client with 2-3 methods, validate wrapper calls match MCP protocol.</standards>
    <locations>tests/unit/sandbox/, tests/fixtures/</locations>
    <ideas>
      <idea ac="1,2,3"
      >Unit test: wrapMCPClient returns object with correct method names from MCP client schema</idea>
      <idea ac="4"
      >Unit test: Vector search identifies relevant tools by intent, returns top-k only</idea>
      <idea ac="5"
      >Unit test: TypeScript type generation converts JSON Schema to valid TypeScript interface</idea>
      <idea ac="6,7"
      >Unit test: Tool wrapper error handling converts MCP errors to JavaScript exceptions with proper stack trace</idea>
      <idea ac="8"
      >Integration test: Inject GitHub client mock, call listCommits() in sandbox code, verify result received</idea>
      <idea ac="8"
      >Integration test: Multiple tools injection (github + filesystem), verify all tools accessible</idea>
      <idea ac="8"
      >Integration test: Vector search filters correctly (only relevant tools injected when intent specified)</idea>
      <idea ac="8"
      >Integration test: Tool call failure in sandbox properly caught as exception, not silent failure</idea>
      <idea ac="9"
      >Security audit: Code review ContextBuilder and wrapMCPClient for eval/Function usage</idea>
      <idea ac="9"
      >Security test: Reject tool names containing __proto__, constructor, prototype patterns</idea>
      <idea ac="9"
      >Security test: Verify wrapper functions cannot access parent process memory or escape sandbox boundaries</idea>
    </ideas>
  </tests>
</story-context>
