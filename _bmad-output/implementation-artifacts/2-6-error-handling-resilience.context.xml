<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>2.6</storyId>
    <title>Error Handling & Resilience</title>
    <status>drafted</status>
    <generatedAt>2025-11-08</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/story-2.6.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>robust error handling throughout Casys Intelligence</iWant>
    <soThat>the system degrades gracefully instead of crashing</soThat>
    <tasks>
      <task id="1"
      >Définir les types d'erreur personnalisés (Casys IntelligenceError, MCPServerError, VectorSearchError, DAGExecutionError, DatabaseError, ConfigurationError, TimeoutError)</task>
      <task id="2"
      >Implémenter l'utilitaire ErrorHandler avec logging et messages user-friendly</task>
      <task id="3">Créer le wrapper de timeout pour les opérations async (default 30s)</task>
      <task id="4"
      >Construire le limiteur de débit (RateLimiter) pour prévenir la surcharge des serveurs MCP</task>
      <task id="5"
      >Ajouter la dégradation gracieuse à la recherche vectorielle (fallback vers keyword search)</task>
      <task id="6">Créer le schéma de table error_log pour persister les erreurs</task>
      <task id="7">Implémenter la capacité de rollback pour les migrations de base de données</task>
      <task id="8">Envelopper toutes les opérations async existantes avec gestion d'erreur</task>
      <task id="9"
      >Écrire des tests d'intégration pour les scénarios d'erreur (timeout, rate limiting, server unreachable)</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC1">Try-catch wrappers autour de all async operations</criterion>
    <criterion id="AC2"
    >Error types définis: MCPServerError, VectorSearchError, DAGExecutionError</criterion>
    <criterion id="AC3">User-friendly error messages avec suggestions de resolution</criterion>
    <criterion id="AC4">Rollback capability pour failed migrations</criterion>
    <criterion id="AC5">Partial workflow success (return succès même si some tools fail)</criterion>
    <criterion id="AC6">Timeout handling (default 30s per tool execution)</criterion>
    <criterion id="AC7">Rate limiting pour prevent MCP server overload</criterion>
    <criterion id="AC8">Error logs persistés pour post-mortem analysis</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/architecture.md" title="Decision Architecture" section="Error Handling">
        <snippet
        >Définit la hiérarchie d'erreurs personnalisées (Casys IntelligenceError, MCPServerError, VectorSearchError, DAGExecutionError) avec pattern try-catch pour toutes les opérations async. Timeout default: 30s per tool. Logging structuré avec std/log (error, warn, info, debug).</snippet>
      </doc>
      <doc path="docs/architecture.md" title="Decision Architecture" section="Logging Strategy">
        <snippet
        >Logger structuré avec std/log, niveaux: error/warn/info/debug. Logs console + file (~/.agentcards/logs/agentcards.log). Format JSON avec timestamp, level, message, context.</snippet>
      </doc>
      <doc path="docs/PRD.md" title="Product Requirements" section="Non-Functional Requirements">
        <snippet
        >NFR003 Reliability: Maintenir taux de succès >99% pour exécution workflows. FR014-FR015: Telemetry opt-in pour tracking métriques (context usage, latency) et logs structurés.</snippet>
      </doc>
      <doc path="docs/epics.md" title="Epic Breakdown" section="Story 2.6">
        <snippet
        >Prerequisites: Story 2.5 (health checks). ACs incluent error types, user-friendly messages, rollback migrations, partial workflow success, timeout 30s, rate limiting, error logs persistés.</snippet>
      </doc>
    </docs>
    <code>
      <artifact
        path="src/mcp/client.ts"
        kind="service"
        symbol="MCPClient"
        lines="28-367"
        reason="Implémente timeout (10s default) et error handling basique pour communications MCP. Nécessite amélioration avec custom error types et retry logic."
      >
      </artifact>
      <artifact
        path="src/dag/executor.ts"
        kind="service"
        symbol="ParallelExecutor"
        lines="32-431"
        reason="Implémente timeout (30s) et partial success handling. Méthode executeWithTimeout (263-290) est un bon pattern à réutiliser. Nécessite custom error types pour DAGExecutionError."
      >
      </artifact>
      <artifact
        path="src/vector/search.ts"
        kind="service"
        symbol="VectorSearch"
        lines="33-137"
        reason="Gestion d'erreur basique avec try-catch. Nécessite VectorSearchError personnalisé et fallback graceful (keyword search)."
      >
      </artifact>
      <artifact
        path="src/db/migrations.ts"
        kind="service"
        symbol="MigrationRunner"
        lines="35-185"
        reason="Système de migration existant avec transaction support (ligne 100-107). Nécessite rollback capability (méthode rollbackTo existe déjà lignes 124-170)."
      >
      </artifact>
      <artifact
        path="src/health/health-checker.ts"
        kind="service"
        symbol="HealthChecker"
        lines="34-272"
        reason="Health checker de story 2.5 avec retry logic (MAX_RETRIES=3). Pattern à intégrer avec rate limiting et error tracking."
      >
      </artifact>
      <artifact
        path="src/telemetry/logger.ts"
        kind="utility"
        symbol="getLogger"
        reason="Logger structuré existant utilisant @std/log. À utiliser pour tous les error logs avec contexte approprié."
      >
      </artifact>
    </code>
    <dependencies>
      <framework
        name="Deno"
        version="2.5"
        ecosystem="deno"
      >
        Runtime TypeScript natif avec support async/await, Deno.Command pour subprocess, native Error class
      </framework>
      <package
        name="@std/log"
        version="0.224.11"
        ecosystem="jsr"
      >
        Logging structuré standard Deno - utilisé pour error logging avec niveaux (error/warn/info/debug)
      </package>
      <package
        name="@electric-sql/pglite"
        version="0.3.11"
        ecosystem="npm"
      >
        PostgreSQL WASM avec transaction support pour rollback migrations et error_log table
      </package>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="C1"
    >DOIT utiliser @std/log pour tous les logs (standard Deno, déjà utilisé dans le codebase)</constraint>
    <constraint id="C2"
    >DOIT maintenir le pattern timeout existant (30s default dans executor, configurable)</constraint>
    <constraint id="C3"
    >DOIT intégrer avec le système de health check existant (src/health/health-checker.ts)</constraint>
    <constraint id="C4"
    >DOIT suivre l'architecture d'erreur définie dans docs/architecture.md (hiérarchie Casys IntelligenceError)</constraint>
    <constraint id="C5"
    >DOIT persister error logs dans PGlite via table error_log (migration nécessaire)</constraint>
    <constraint id="C6"
    >DOIT conserver partial success handling existant dans ParallelExecutor</constraint>
    <constraint id="C7"
    >DOIT utiliser le système de transaction PGlite existant pour rollback migrations</constraint>
    <constraint id="C8"
    >NE PAS ajouter de dépendances externes - utiliser Error natif TypeScript</constraint>
    <constraint id="C9"
    >DOIT maintenir la compatibilité avec le timeout pattern dans executeWithTimeout (dag/executor.ts:263-290)</constraint>
  </constraints>

  <interfaces>
    <interface
      name="Casys IntelligenceError"
      kind="class"
      signature="extends Error"
      path="src/errors/error-types.ts"
    >
      Base error class avec code, recoverable flag, et suggestion field
    </interface>
    <interface
      name="MCPServerError"
      kind="class"
      signature="extends Casys IntelligenceError"
      path="src/errors/error-types.ts"
    >
      Error spécifique aux connexions/communications MCP server avec serverId
    </interface>
    <interface
      name="VectorSearchError"
      kind="class"
      signature="extends Casys IntelligenceError"
      path="src/errors/error-types.ts"
    >
      Error pour échecs de recherche vectorielle avec query optionnel
    </interface>
    <interface
      name="DAGExecutionError"
      kind="class"
      signature="extends Casys IntelligenceError"
      path="src/errors/error-types.ts"
    >
      Error pour échecs d'exécution DAG avec taskId optionnel et recoverable flag
    </interface>
    <interface
      name="ErrorHandler"
      kind="class"
      signature="static methods"
      path="src/errors/error-handler.ts"
    >
      Utilitaire avec handle(), wrapAsync(), logToDatabase() pour gestion centralisée des erreurs
    </interface>
    <interface
      name="RateLimiter"
      kind="class"
      signature="checkLimit(serverId): Promise&lt;boolean&gt;"
      path="src/utils/rate-limiter.ts"
    >
      Rate limiting par serverId avec sliding window (10 req/sec default)
    </interface>
    <interface
      name="withTimeout"
      kind="function"
      signature="&lt;T&gt;(operation: Promise&lt;T&gt;, timeoutMs: number, operationName: string): Promise&lt;T&gt;"
      path="src/utils/timeout.ts"
    >
      Timeout wrapper générique réutilisable pour toutes les opérations async
    </interface>
  </interfaces>

  <tests>
    <standards
    >Tests unitaires avec Deno.test dans tests/unit/, tests d'intégration dans tests/integration/, mocks dans tests/mocks/. Utilisation de @std/assert pour assertions. Pattern: co-location des tests unitaires avec source ou regroupement par module dans tests/unit/. Coverage target: >80% (ligne 8 deno.json).</standards>
    <locations>
      <location>tests/unit/errors/ - Tests unitaires pour error types et error handler</location>
      <location>tests/unit/utils/ - Tests pour timeout wrapper et rate limiter</location>
      <location>tests/integration/ - Tests d'intégration pour error scenarios</location>
      <location>tests/mocks/ - Mocks pour MCP servers et database (déjà existants)</location>
    </locations>
    <ideas>
      <test id="T1" maps_to="AC1,AC2"
      >Test MCP server unreachable - vérifier MCPServerError thrown et suggestion correcte</test>
      <test id="T2" maps_to="AC6"
      >Test timeout - opération lente doit throw TimeoutError après 30s avec message clair</test>
      <test id="T3" maps_to="AC7"
      >Test rate limiting - 11ème requête dans 1 seconde doit être bloquée (limit 10 req/sec)</test>
      <test id="T4" maps_to="AC4"
      >Test migration rollback - échec de migration doit rollback vers version précédente</test>
      <test id="T5" maps_to="AC5"
      >Test partial workflow success - DAG avec 1 task failed et 2 success doit retourner les 2 succès</test>
      <test id="T6" maps_to="AC3"
      >Test error handler user-friendly messages - vérifier messages et suggestions présents</test>
      <test id="T7" maps_to="AC8"
      >Test error log persistence - vérifier insertion dans error_log table avec context</test>
      <test id="T8" maps_to="AC2"
      >Test VectorSearchError - échec vector search doit fallback vers keyword search gracefully</test>
      <test id="T9" maps_to="AC1"
      >Test ErrorHandler.wrapAsync - wrapper doit catch et log correctement avec fallback</test>
    </ideas>
  </tests>
</story-context>
